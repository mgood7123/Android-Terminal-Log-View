<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="MSSmartTagsPreventParsing" content="TRUE" />
 <title>RTFM mksh(1)</title>
 <meta name="robots" content="index, follow" />
 <link rel="canonical" href="https://www.mirbsd.org/mani386/mksh.1" />
 <style type="text/css"><!--/*--><![CDATA[/*><!--*/
	body {
		background-color:#000000;
		color:#666666;
		font-family:serif;
	}
	a {
		color:inherit;
		text-decoration:none;
		border-bottom:1px dashed;
	}
	a:visited {
		text-decoration:none;
		border-bottom:1px dotted;
	}
	a:hover {
		text-decoration:none;
		border-bottom:1px double;
	}
	pre {
		line-height:1.12;
		color:#FFBF00;
	}
	b {
		color:#FFEF00;
		font-weight:normal;
	}
	i {
		font-style:normal;
		border-bottom:1px solid #FFBF00;
	}
	b i,i b {
		color:#FFEF00;
		font-weight:normal;
		font-style:normal;
		border-bottom:1px solid #FFEF00;
	}
	h1 {
		color:#FFEF00;
		font-size:xx-large;
		font-family:serif;
	}
	h2 {
		color:#FFFFFF;
		font-size:x-large;
		font-family:sans-serif;
	}
	h3 {
		color:#CCCCCC;
		font-size:large;
		font-family:sans-serif;
	}
 /*]]>*/--></style>
</head><body>
<h1>MirOS Manual: mksh(1)</h1>
<pre>MKSH(1)                      BSD Reference Manual                      MKSH(1)
</pre><h2>NAME</h2><pre>
     <b>mksh</b>, <b>sh</b> - MirBSD Korn shell
</pre><h2>SYNOPSIS</h2><pre>
     <b>mksh</b> [<b>-+abCefhiklmnprUuvXx</b>] [<b>-T</b> [!]<i>tty</i> | -] [<b>-+o</b> <i>option</i>] [<b>-c</b> <i>string</i> | <b>-s</b>
          | <i>file</i> [<i>argument</i> ...]]
     <b>builtin-name</b> [<i>argument</i> ...]
</pre><h2>DESCRIPTION</h2><pre>
     <b>mksh</b> is a command interpreter intended for both interactive and shell
     script use. Its command language is a superset of the sh(C) shell
     language and largely compatible to the original Korn shell. At times,
     this manual page may give scripting advice; while it sometimes does take
     portable shell scripting or various standards into account all informa-
     tion is first and foremost presented with <b>mksh</b> in mind and should be tak-
     en as such.
</pre><h3>I use Android, OS/2, etc. so what...?</h3><pre>
     Please see the FAQ at the end of this document.
</pre><h3>Invocation</h3><pre>
     Most builtins can be called directly, for example if a link points from
     its name to the shell; not all make sense, have been tested or work at
     all though.

     The options are as follows:

     <b>-c</b> <i>string</i>  <b>mksh</b> will execute the command(s) contained in <i>string</i>.

     <b>-i</b>         Interactive shell. A shell that reads commands from standard
                input is "interactive" if this option is used or if both stan-
                dard input and standard error are attached to a tty(4). An in-
                teractive shell has job control enabled, ignores the SIGINT,
                SIGQUIT and SIGTERM signals, and prints prompts before reading
                input (see the PS1 and PS2 parameters). It also processes the
                ENV parameter or the <i>mkshrc</i> file (see below). For non-
                interactive shells, the <b>trackall</b> option is on by default (see
                the <b>set</b> command below).

     <b>-l</b>         Login shell. If the basename the shell is called with (i.e.
                argv[0]) starts with '-' or if this option is used, the shell
                is assumed to be a login shell; see <i>Startup files</i> below.

     <b>-p</b>         Privileged shell. A shell is "privileged" if the real user ID
                or group ID does not match the effective user ID or group ID
                (see getuid(2) and getgid(2)). Clearing the privileged option
                causes the shell to set its effective user ID (group ID) to
                its real user ID (group ID). For further implications, see
                <i>Startup files</i>. If the shell is privileged and this flag is not
                explicitly set, the "privileged" option is cleared automati-
                cally after processing the startup files.

     <b>-r</b>         Restricted shell. A shell is "restricted" if this option is
                used. The following restrictions come into effect after the
                shell processes any profile and ENV files:

                •   The <b>cd</b> (and <b>chdir</b>) command is disabled.
                •   The SHELL, ENV and PATH parameters cannot be changed.
                •   Command names can't be specified with absolute or relative
                    paths.
                •   The <b>-p</b> option of the built-in command <b>command</b> can't be
                    used.
                •   Redirections that create files can't be used (i.e. "&#62;",
                    "&#62;|", "&#62;&#62;", "&#60;&#62;").

     <b>-s</b>         The shell reads commands from standard input; all non-option
                arguments are positional parameters.

     <b>-T</b> <i>name</i>    Spawn <b>mksh</b> on the tty(4) device given. The paths <i>name</i>,
                <i>/dev/ttyCname</i> and <i>/dev/ttyname</i> are attempted in order. Unless
                <i>name</i> begins with an exclamation mark ('!'), this is done in a
                subshell and returns immediately. If <i>name</i> is a dash ('-'), de-
                tach from controlling terminal (daemonise) instead.

     In addition to the above, the options described in the <b>set</b> built-in com-
     mand can also be used on the command line: both [<b>-+abCefhkmnuvXx</b>] and
     [<b>-+o</b> <i>option</i>] can be used for single letter or long options, respectively.

     If neither the <b>-c</b> nor the <b>-s</b> option is specified, the first non-option
     argument specifies the name of a file the shell reads commands from. If
     there are no non-option arguments, the shell reads commands from the
     standard input. The name of the shell (i.e. the contents of $0) is deter-
     mined as follows: if the <b>-c</b> option is used and there is a non-option ar-
     gument, it is used as the name; if commands are being read from a file,
     the file is used as the name; otherwise, the basename the shell was
     called with (i.e. argv[0]) is used.

     The exit status of the shell is 127 if the command file specified on the
     command line could not be opened, or non-zero if a fatal syntax error oc-
     curred during the execution of a script. In the absence of fatal errors,
     the exit status is that of the last command executed, or zero if no com-
     mand is executed.
</pre><h3>Startup files</h3><pre>
     For the actual location of these files, see <i>FILES</i>. A login shell
     processes the system profile first. A privileged shell then processes the
     suid profile. A non-privileged login shell processes the user profile
     next. A non-privileged interactive shell checks the value of the ENV
     parameter after subjecting it to parameter, command, arithmetic and tilde
     ('~') substitution; if unset or empty, the user mkshrc profile is pro-
     cessed; otherwise, if a file whose name is the substitution result ex-
     ists, it is processed; non-existence is silently ignored. A privileged
     shell then drops privileges if neither was the <b>-p</b> option given on the
     command line nor set during execution of the startup files.
</pre><h3>Command syntax</h3><pre>
     The shell begins parsing its input by removing any backslash-newline com-
     binations, then breaking it into <i>words</i>. Words (which are sequences of
     characters) are delimited by unquoted whitespace characters (space, tab
     and newline) or meta-characters ('&#60;', '&#62;', '|', ';', '(', ')' and '&#38;').
     Aside from delimiting words, spaces and tabs are ignored, while newlines
     usually delimit commands. The meta-characters are used in building the
     following <i>tokens</i>: "&#60;", "&#60;&#38;", "&#60;&#60;", "&#60;&#60;&#60;", "&#62;", "&#62;&#38;", "&#62;&#62;", "&#38;&#62;", etc. are
     used to specify redirections (see <i>Input/output redirection</i> below); "|" is
     used to create pipelines; "|&#38;" is used to create co-processes (see <i>Co-</i>
     <i>processes</i> below); ";" is used to separate commands; "&#38;" is used to create
     asynchronous pipelines; "&#38;&#38;" and "||" are used to specify conditional ex-
     ecution; ";;", ";&#38;" and ";|" are used in <b>case</b> statements; "(( ... ))" is
     used in arithmetic expressions; and lastly, "( ... )" is used to create
     subshells.

     Whitespace and meta-characters can be quoted individually using a
     backslash ('\'), or in groups using double ('"') or single ("'") quotes.
     Note that the following characters are also treated specially by the
     shell and must be quoted if they are to represent themselves: '\', '"',
     "'", '#', '$', '`', '~', '{', '}', '*', '?' and '['. The first three of
     these are the above mentioned quoting characters (see <i>Quoting</i> below);
     '#', if used at the beginning of a word, introduces a comment - every-
     thing after the '#' up to the nearest newline is ignored; '$' is used to
     introduce parameter, command and arithmetic substitutions (see
     <i>Substitution</i> below); '`' introduces an old-style command substitution
     (see <i>Substitution</i> below); '~' begins a directory expansion (see <i>Tilde</i>
     <i>expansion</i> below); '{' and '}' delimit csh(1)-style alternations (see
     <i>Brace expansion</i> below); and finally, '*', '?' and '[' are used in file
     name generation (see <i>File name patterns</i> below).

     As words and tokens are parsed, the shell builds commands, of which there
     are two basic types: <i>simple-commands</i>, typically programmes that are exe-
     cuted, and <i>compound-commands</i>, such as <b>for</b> and <b>if</b> statements, grouping
     constructs and function definitions.

     A simple-command consists of some combination of parameter assignments
     (see <i>Parameters</i> below), input/output redirections (see <i>Input/output</i>
     <i>redirections</i> below) and command words; the only restriction is that
     parameter assignments come before any command words. The command words,
     if any, define the command that is to be executed and its arguments. The
     command may be a shell built-in command, a function or an external com-
     mand (i.e. a separate executable file that is located using the PATH
     parameter; see <i>Command execution</i> below). Note that all command constructs
     have an exit status: for external commands, this is related to the status
     returned by wait(2) (if the command could not be found, the exit status
     is 127; if it could not be executed, the exit status is 126); the exit
     status of other command constructs (built-in commands, functions,
     compound-commands, pipelines, lists, etc.) are all well-defined and are
     described where the construct is described. The exit status of a command
     consisting only of parameter assignments is that of the last command sub-
     stitution performed during the parameter assignment or 0 if there were no
     command substitutions.

     Commands can be chained together using the "|" token to form pipelines,
     in which the standard output of each command but the last is piped (see
     pipe(2)) to the standard input of the following command. The exit status
     of a pipeline is that of its last command, unless the <b>pipefail</b> option is
     set (see there). All commands of a pipeline are executed in separate sub-
     shells; this is allowed by POSIX but differs from both variants of AT&#38;T
     UNIX <b>ksh</b>, where all but the last command were executed in subshells; see
     the <b>read</b> builtin's description for implications and workarounds. A pipe-
     line may be prefixed by the "!" reserved word which causes the exit
     status of the pipeline to be logically complemented: if the original
     status was 0, the complemented status will be 1; if the original status
     was not 0, the complemented status will be 0.

     <i>Lists</i> of commands can be created by separating pipelines by any of the
     following tokens: "&#38;&#38;", "||", "&#38;", "|&#38;" and ";". The first two are for
     conditional execution: "<i>cmd1</i> &#38;&#38; <i>cmd2</i>" executes <i>cmd2</i> only if the exit
     status of <i>cmd1</i> is zero; "||" is the opposite - <i>cmd2</i> is executed only if
     the exit status of <i>cmd1</i> is non-zero. "&#38;&#38;" and "||" have equal precedence
     which is higher than that of "&#38;", "|&#38;" and ";", which also have equal
     precedence. Note that the "&#38;&#38;" and "||" operators are "left-associative".
     For example, both of these commands will print only "bar":

           $ false &#38;&#38; echo foo || echo bar
           $ true || echo foo &#38;&#38; echo bar

     The "&#38;" token causes the preceding command to be executed asynchronously;
     that is, the shell starts the command but does not wait for it to com-
     plete (the shell does keep track of the status of asynchronous commands;
     see <i>Job control</i> below). When an asynchronous command is started when job
     control is disabled (i.e. in most scripts), the command is started with
     signals SIGINT and SIGQUIT ignored and with input redirected from
     <i>/dev/null</i> (however, redirections specified in the asynchronous command
     have precedence). The "|&#38;" operator starts a co-process which is a spe-
     cial kind of asynchronous process (see <i>Co-processes</i> below). Note that a
     command must follow the "&#38;&#38;" and "||" operators, while it need not follow
     "&#38;", "|&#38;" or ";". The exit status of a list is that of the last command
     executed, with the exception of asynchronous lists, for which the exit
     status is 0.

     Compound commands are created using the following reserved words. These
     words are only recognised if they are unquoted and if they are used as
     the first word of a command (i.e. they can't be preceded by parameter as-
     signments or redirections):

           case     else     function     then      !       (
           do       esac     if           time      [[      ((
           done     fi       in           until     {
           elif     for      select       while     }

     In the following compound command descriptions, command lists (denoted as
     <i>list</i>) that are followed by reserved words must end with a semicolon, a
     newline or a (syntactically correct) reserved word. For example, the fol-
     lowing are all valid:

           $ { echo foo; echo bar; }
           $ { echo foo; echo bar&#60;newline&#62;}
           $ { { echo foo; echo bar; } }

     This is not valid:

           $ { echo foo; echo bar }

     (<i>list</i>)
           Execute <i>list</i> in a subshell. There is no implicit way to pass en-
           vironment changes from a subshell back to its parent.

     { <i>list</i>; }
           Compound construct; <i>list</i> is executed, but not in a subshell. Note
           that "{" and "}" are reserved words, not meta-characters.

     case <i>word</i> in [[(] <i>pattern</i> [| <i>pattern</i>] ...) <i>list</i> <b>terminator</b>] ... esac
           The <b>case</b> statement attempts to match <i>word</i> against a specified
           <i>pattern</i>; the <i>list</i> associated with the first successfully matched
           pattern is executed. Patterns used in <b>case</b> statements are the same
           as those used for file name patterns except that the restrictions
           regarding '.' and '/' are dropped. Note that any unquoted space be-
           fore and after a pattern is stripped; any space within a pattern
           must be quoted. Both the word and the patterns are subject to
           parameter, command and arithmetic substitution, as well as tilde
           substitution.

           For historical reasons, open and close braces may be used instead
           of <b>in</b> and <b>esac</b> e.g. <b>case $foo { *) echo bar ;; }</b>.

           The list <b>terminator</b>s are:

           ";;"  Terminate after the list.

           ";&#38;"  Fall through into the next list.

           ";|"  Evaluate the remaining pattern-list tuples.

           The exit status of a <b>case</b> statement is that of the executed <i>list</i>;
           if no <i>list</i> is executed, the exit status is zero.

     for <i>name</i> [in <i>word</i> ...]; do <i>list</i>; done
           For each <i>word</i> in the specified word list, the parameter <i>name</i> is set
           to the word and <i>list</i> is executed. If <b>in</b> is not used to specify a
           word list, the positional parameters ($1, $2, etc.) are used in-
           stead. For historical reasons, open and close braces may be used
           instead of <b>do</b> and <b>done</b> e.g. <b>for i; { echo $i; }</b>. The exit status of
           a <b>for</b> statement is the last exit status of <i>list</i>; if <i>list</i> is never
           executed, the exit status is zero.

     if <i>list</i>; then <i>list</i>; [elif <i>list</i>; then <i>list</i>;] ... [else <i>list</i>;] fi
           If the exit status of the first <i>list</i> is zero, the second <i>list</i> is
           executed; otherwise, the <i>list</i> following the <b>elif</b>, if any, is exe-
           cuted with similar consequences. If all the lists following the <b>if</b>
           and <b>elif</b>s fail (i.e. exit with non-zero status), the <i>list</i> following
           the <b>else</b> is executed. The exit status of an <b>if</b> statement is that of
           non-conditional <i>list</i> that is executed; if no non-conditional <i>list</i>
           is executed, the exit status is zero.

     select <i>name</i> [in <i>word</i> ...]; do <i>list</i>; done
           The <b>select</b> statement provides an automatic method of presenting the
           user with a menu and selecting from it. An enumerated list of the
           specified <i>word</i>(s) is printed on standard error, followed by a
           prompt (PS3: normally "#? "). A number corresponding to one of the
           enumerated words is then read from standard input, <i>name</i> is set to
           the selected word (or unset if the selection is not valid), REPLY
           is set to what was read (leading/trailing space is stripped), and
           <i>list</i> is executed. If a blank line (i.e. zero or more IFS octets) is
           entered, the menu is reprinted without executing <i>list</i>.

           When <i>list</i> completes, the enumerated list is printed if REPLY is
           empty, the prompt is printed, and so on. This process continues un-
           til an end-of-file is read, an interrupt is received, or a <b>break</b>
           statement is executed inside the loop. If "in <i>word</i> ..." is omitted,
           the positional parameters are used (i.e. $1, $2, etc.). For histor-
           ical reasons, open and close braces may be used instead of <b>do</b> and
           <b>done</b> e.g. <b>select i; { echo $i; }</b>. The exit status of a <b>select</b>
           statement is zero if a <b>break</b> statement is used to exit the loop,
           non-zero otherwise.

     until <i>list</i>; do <i>list</i>; done
           This works like <b>while</b>, except that the body is executed only while
           the exit status of the first <i>list</i> is non-zero.

     while <i>list</i>; do <i>list</i>; done
           A <b>while</b> is a pre-checked loop. Its body is executed as often as the
           exit status of the first <i>list</i> is zero. The exit status of a <b>while</b>
           statement is the last exit status of the <i>list</i> in the body of the
           loop; if the body is not executed, the exit status is zero.

     function <i>name</i> { <i>list</i>; }
           Defines the function <i>name</i> (see <i>Functions</i> below). Note that redirec-
           tions specified after a function definition are performed whenever
           the function is executed, not when the function definition is exe-
           cuted.

     <i>name() command</i>
           Mostly the same as <b>function</b> (see <i>Functions</i> below). Whitespace
           (space or tab) after <i>name</i> will be ignored most of the time.

     function <i>name</i>() { <i>list</i>; }
           The same as <i>name</i>() (<b>bash</b>ism). The <b>function</b> keyword is ignored.

     <b>time</b> [<b>-p</b>] [<i>pipeline</i>]
           The <i>Command execution</i> section describes the <b>time</b> reserved word.

     (( <i>expression</i> ))
           The arithmetic expression <i>expression</i> is evaluated; equivalent to
           "let "<i>expression</i>"" (see <i>Arithmetic expressions</i> and the <b>let</b> command,
           below) in a compound construct.

     [[ <i>expression</i> ]]
           Similar to the <b>test</b> and <b>[ ... ]</b> commands (described later), with
           the following exceptions:

           •   Field splitting and file name generation are not performed on
               arguments.

           •   The <b>-a</b> (AND) and <b>-o</b> (OR) operators are replaced with "&#38;&#38;" and
               "||", respectively.

           •   Operators (e.g. "-f", "=", "!") must be unquoted.

           •   Parameter, command and arithmetic substitutions are performed
               as expressions are evaluated and lazy expression evaluation is
               used for the "&#38;&#38;" and "||" operators. This means that in the
               following statement, <b>$(&#60;foo</b>) is evaluated if and only if the
               file <i>foo</i> exists and is readable:

                     $ [[ -r foo &#38;&#38; $(&#60;foo) = b*r ]]

           •   The second operand of the "!=" and "=" expressions are a subset
               of patterns (e.g. the comparison <b>[[ foobar = f*r ]]</b> succeeds).
               This even works indirectly:

                     $ bar=foobar; baz='f*r'
                     $ [[ $bar = $baz ]]; echo $?
                     $ [[ $bar = "$baz" ]]; echo $?

               Perhaps surprisingly, the first comparison succeeds, whereas
               the second doesn't. This does not apply to all extglob meta-
               characters, currently.
</pre><h3>Quoting</h3><pre>
     Quoting is used to prevent the shell from treating characters or words
     specially. There are three methods of quoting. First, '\' quotes the fol-
     lowing character, unless it is at the end of a line, in which case both
     the '\' and the newline are stripped. Second, a single quote ("'") quotes
     everything up to the next single quote (this may span lines). Third, a
     double quote ('"') quotes all characters, except '$', '\' and '`', up to
     the next unescaped double quote. '$' and '`' inside double quotes have
     their usual meaning (i.e. parameter, arithmetic or command substitution)
     except no field splitting is carried out on the results of double-quoted
     substitutions, and the old-style form of command substitution has
     backslash-quoting for double quotes enabled. If a '\' inside a double-
     quoted string is followed by '"', '$', '\' or '`', only the '\' is re-
     moved, i.e. the combination is replaced by the second character; if it is
     followed by a newline, both the '\' and the newline are stripped; other-
     wise, both the '\' and the character following are unchanged.

     If a single-quoted string is preceded by an unquoted '$', C style
     backslash expansion (see below) is applied (even single quote characters
     inside can be escaped and do not terminate the string then); the expanded
     result is treated as any other single-quoted string. If a double-quoted
     string is preceded by an unquoted '$', the '$' is simply ignored.
</pre><h3>Backslash expansion</h3><pre>
     In places where backslashes are expanded, certain C and AT&#38;T UNIX <b>ksh</b> or
     GNU <b>bash</b> style escapes are translated. These include "\a", "\b", "\f",
     "\n", "\r", "\t", "\U########", "\u####" and "\v". For "\U########" and
     "\u####", "#" means a hexadecimal digit, of which there may be none up to
     four or eight; these escapes translate a Unicode codepoint to UTF-8.
     Furthermore, "\E" and "\e" expand to the escape character.

     In the <b>print</b> builtin mode, "\"", "\'" and "\?" are explicitly excluded;
     octal sequences must have the none up to three octal digits "#" prefixed
     with the digit zero ("\0###"); hexadecimal sequences "\x##" are limited
     to none up to two hexadecimal digits "#"; both octal and hexadecimal se-
     quences convert to raw octets; "\#", where # is none of the above,
     translates to \# (backslashes are retained).

     Backslash expansion in the C style mode slightly differs: octal sequences
     "\###" must have no digit zero prefixing the one up to three octal digits
     "#" and yield raw octets; hexadecimal sequences "\x#*" greedily eat up as
     many hexadecimal digits "#" as they can and terminate with the first
     non-hexadecimal digit; these translate a Unicode codepoint to UTF-8. The
     sequence "\c#", where "#" is any octet, translates to Ctrl-# (which basi-
     cally means, "\c?" becomes DEL, everything else is bitwise ANDed with
     0x1F). Finally, "\#", where # is none of the above, translates to # (has
     the backslash trimmed), even if it is a newline.
</pre><h3>Aliases</h3><pre>
     There are two types of aliases: normal command aliases and tracked
     aliases. Command aliases are normally used as a short hand for a long or
     often used command. The shell expands command aliases (i.e. substitutes
     the alias name for its value) when it reads the first word of a command.
     An expanded alias is re-processed to check for more aliases. If a command
     alias ends in a space or tab, the following word is also checked for
     alias expansion. The alias expansion process stops when a word that is
     not an alias is found, when a quoted word is found, or when an alias word
     that is currently being expanded is found. Aliases are specifically an
     interactive feature: while they do happen to work in scripts and on the
     command line in some cases, aliases are expanded during lexing, so their
     use must be in a separate command tree from their definition; otherwise,
     the alias will not be found. Noticeably, command lists (separated by
     semicolon, in command substitutions also by newline) may be one same
     parse tree.

     The following command aliases are defined automatically by the shell:

           autoload='\\builtin typeset -fu'
           functions='\\builtin typeset -f'
           hash='\\builtin alias -t'
           history='\\builtin fc -l'
           integer='\\builtin typeset -i'
           local='\\builtin typeset'
           login='\\builtin exec login'
           nameref='\\builtin typeset -n'
           nohup='nohup '
           r='\\builtin fc -e -'
           type='\\builtin whence -v'

     Tracked aliases allow the shell to remember where it found a particular
     command. The first time the shell does a path search for a command that
     is marked as a tracked alias, it saves the full path of the command. The
     next time the command is executed, the shell checks the saved path to see
     that it is still valid, and if so, avoids repeating the path search.
     Tracked aliases can be listed and created using <b>alias -t</b>. Note that
     changing the PATH parameter clears the saved paths for all tracked
     aliases. If the <b>trackall</b> option is set (i.e. <b>set -o trackall</b> or <b>set -h)</b>,
     the shell tracks all commands. This option is set automatically for non-
     interactive shells. For interactive shells, only the following commands
     are automatically tracked: cat(1), cc(1), chmod(1), cp(1), date(1),
     ed(1), emacs(1), grep(1), ls(1), make(1), mv(1), pr(1), rm(1), sed(1),
     sh(1), vi(1) and who(1).
</pre><h3>Substitution</h3><pre>
     The first step the shell takes in executing a simple-command is to per-
     form substitutions on the words of the command. There are three kinds of
     substitution: parameter, command and arithmetic. Parameter substitutions,
     which are described in detail in the next section, take the form <i>$name</i> or
     ${...}; command substitutions take the form $(<i>command</i>) or (deprecated)
     `<i>command</i>` or (executed in the current environment) ${ <i>command</i>;} and strip
     trailing newlines; and arithmetic substitutions take the form
     $((<i>expression</i>)). Parsing the current-environment command substitution re-
     quires a space, tab or newline after the opening brace and that the clos-
     ing brace be recognised as a keyword (i.e. is preceded by a newline or
     semicolon). They are also called funsubs (function substitutions) and
     behave like functions in that <b>local</b> and <b>return</b> work, and in that <b>exit</b>
     terminates the parent shell; shell options are shared.

     Another variant of substitution are the valsubs (value substitutions)
     ${|<i>command</i>;} which are also executed in the current environment, like
     funsubs, but share their I/O with the parent; instead, they evaluate to
     whatever the, initially empty, expression-local variable REPLY is set to
     within the <i>command</i>s.

     If a substitution appears outside of double quotes, the results of the
     substitution are generally subject to word or field splitting according
     to the current value of the IFS parameter. The IFS parameter specifies a
     list of octets which are used to break a string up into several words;
     any octets from the set space, tab and newline that appear in the IFS oc-
     tets are called "IFS whitespace". Sequences of one or more IFS whitespace
     octets, in combination with zero or one non-IFS whitespace octets, delim-
     it a field. As a special case, leading and trailing IFS whitespace is
     stripped (i.e. no leading or trailing empty field is created by it);
     leading or trailing non-IFS whitespace does create an empty field.

     Example: If IFS is set to "&#60;space&#62;:" and VAR is set to
     "&#60;space&#62;A&#60;space&#62;:&#60;space&#62;&#60;space&#62;B::D", the substitution for $VAR results
     in four fields: "A", "B", "" (an empty field) and "D". Note that if the
     IFS parameter is set to the empty string, no field splitting is done; if
     it is unset, the default value of space, tab and newline is used.

     Also, note that the field splitting applies only to the immediate result
     of the substitution. Using the previous example, the substitution for
     $VAR:E results in the fields: "A", "B", "" and "D:E", not "A", "B", "",
     "D" and "E". This behavior is POSIX compliant, but incompatible with some
     other shell implementations which do field splitting on the word which
     contained the substitution or use IFS as a general whitespace delimiter.

     The results of substitution are, unless otherwise specified, also subject
     to brace expansion and file name expansion (see the relevant sections
     below).

     A command substitution is replaced by the output generated by the speci-
     fied command which is run in a subshell. For $(<i>command</i>) and ${|<i>command</i>;}
     and ${ <i>command</i>;} substitutions, normal quoting rules are used when
     <i>command</i> is parsed; however, for the deprecated `<i>command</i>` form, a '\' fol-
     lowed by any of '$', '`' or '\' is stripped (as is '"' when the substitu-
     tion is part of a double-quoted string); a backslash '\' followed by any
     other character is unchanged. As a special case in command substitutions,
     a command of the form &#60;<i>file</i> is interpreted to mean substitute the con-
     tents of <i>file</i>. Note that <b>$(&#60;foo</b>) has the same effect as <b>$(cat foo)</b>.

     Note that some shells do not use a recursive parser for command substitu-
     tions, leading to failure for certain constructs; to be portable, use as
     workaround "x=$(cat) &#60;&#60;\EOF" (or the newline-keeping "x=&#60;&#60;\EOF" exten-
     sion) instead to merely slurp the string. IEEE Std 1003.1 ("POSIX")
     recommends using case statements of the form x=$(case $foo in (bar) echo
     $bar ;; (*) echo $baz ;; esac) instead, which would work but not serve as
     example for this portability issue.

           x=$(case $foo in bar) echo $bar ;; *) echo $baz ;; esac)
           # above fails to parse on old shells; below is the workaround
           x=$(eval $(cat)) &#60;&#60;\EOF
           case $foo in bar) echo $bar ;; *) echo $baz ;; esac
           EOF

     Arithmetic substitutions are replaced by the value of the specified ex-
     pression. For example, the command <b>print $((2+3*4)</b>) displays 14. See
     <i>Arithmetic expressions</i> for a description of an expression.
</pre><h3>Parameters</h3><pre>
     Parameters are shell variables; they can be assigned values and their
     values can be accessed using a parameter substitution. A parameter name
     is either one of the special single punctuation or digit character param-
     eters described below, or a letter followed by zero or more letters or
     digits ('_' counts as a letter). The latter form can be treated as arrays
     by appending an array index of the form [<i>expr</i>] where <i>expr</i> is an arithmet-
     ic expression. Array indices in <b>mksh</b> are limited to the range 0 through
     4294967295, inclusive. That is, they are a 32-bit unsigned integer.

     Parameter substitutions take the form <i>$name</i>, ${<i>name</i>} or ${<i>name</i>[<i>expr</i>]}
     where <i>name</i> is a parameter name. Substitution of all array elements with
     ${<i>name</i>[*]} and ${<i>name</i>[@]} works equivalent to $* and $@ for positional
     parameters. If substitution is performed on a parameter (or an array
     parameter element) that is not set, an empty string is substituted unless
     the <b>nounset</b> option (<b>set -u</b>) is set, in which case an error occurs.

     Parameters can be assigned values in a number of ways. First, the shell
     implicitly sets some parameters like "#", "PWD" and "$"; this is the only
     way the special single character parameters are set. Second, parameters
     are imported from the shell's environment at startup. Third, parameters
     can be assigned values on the command line: for example, <b>FOO=bar</b> sets the
     parameter "FOO" to "bar"; multiple parameter assignments can be given on
     a single command line and they can be followed by a simple-command, in
     which case the assignments are in effect only for the duration of the
     command (such assignments are also exported; see below for the implica-
     tions of this). Note that both the parameter name and the '=' must be un-
     quoted for the shell to recognise a parameter assignment. The construct
     <b>FOO+=baz</b> is also recognised; the old and new values are immediately con-
     catenated. The fourth way of setting a parameter is with the <b>export</b>,
     <b>global</b>, <b>readonly</b> and <b>typeset</b> commands; see their descriptions in the
     <i>Command execution</i> section. Fifth, <b>for</b> and <b>select</b> loops set parameters as
     well as the <b>getopts</b>, <b>read</b> and <b>set -A</b> commands. Lastly, parameters can be
     assigned values using assignment operators inside arithmetic expressions
     (see <i>Arithmetic expressions</i> below) or using the ${<i>name</i>=<i>value</i>} form of the
     parameter substitution (see below).

     Parameters with the export attribute (set using the <b>export</b> or <b>typeset -x</b>
     commands, or by parameter assignments followed by simple commands) are
     put in the environment (see environ(7)) of commands run by the shell as
     <i>name</i>=<i>value</i> pairs. The order in which parameters appear in the environment
     of a command is unspecified. When the shell starts up, it extracts param-
     eters and their values from its environment and automatically sets the
     export attribute for those parameters.

     Modifiers can be applied to the ${<i>name</i>} form of parameter substitution:

     ${<i>name:-word</i>}
             If <i>name</i> is set and not empty, it is substituted; otherwise, <i>word</i>
             is substituted.

     ${<i>name</i>:+<i>word</i>}
             If <i>name</i> is set and not empty, <i>word</i> is substituted; otherwise,
             nothing is substituted.

     ${<i>name</i>:=<i>word</i>}
             If <i>name</i> is set and not empty, it is substituted; otherwise, it is
             assigned <i>word</i> and the resulting value of <i>name</i> is substituted.

     ${<i>name:?word</i>}
             If <i>name</i> is set and not empty, it is substituted; otherwise, <i>word</i>
             is printed on standard error (preceded by <i>name</i>:) and an error oc-
             curs (normally causing termination of a shell script, function,
             or a script sourced using the "." built-in). If <i>word</i> is omitted,
             the string "parameter null or not set" is used instead.

     Note that, for all of the above, <i>word</i> is actually considered quoted, and
     special parsing rules apply. The parsing rules also differ on whether the
     expression is double-quoted: <i>word</i> then uses double-quoting rules, except
     for the double quote itself ('"') and the closing brace, which, if
     backslash escaped, gets quote removal applied.

     In the above modifiers, the ':' can be omitted, in which case the condi-
     tions only depend on <i>name</i> being set (as opposed to set and not empty). If
     <i>word</i> is needed, parameter, command, arithmetic and tilde substitution are
     performed on it; if <i>word</i> is not needed, it is not evaluated.

     The following forms of parameter substitution can also be used (if <i>name</i>
     is an array, the element with the key "0" will be substituted in scalar
     context):

     ${#<i>name</i>}
             The number of positional parameters if <i>name</i> is "*", "@" or not
             specified; otherwise the length (in characters) of the string
             value of parameter <i>name</i>.

     ${#<i>name</i>[*]}
     ${#<i>name</i>[@]}
             The number of elements in the array <i>name</i>.

     ${%<i>name</i>}
             The width (in screen columns) of the string value of parameter
             <i>name</i>, or -1 if ${<i>name</i>} contains a control character.

     ${!<i>name</i>}
             The name of the variable referred to by <i>name</i>. This will be <i>name</i>
             except when <i>name</i> is a name reference (bound variable), created by
             the <b>nameref</b> command (which is an alias for <b>typeset -n)</b>. <i>name</i> can-
             not be one of most special parameters (see below).

     ${!<i>name</i>[*]}
     ${!<i>name</i>[@]}
             The names of indices (keys) in the array <i>name</i>.

     ${<i>name#pattern</i>}
     ${<i>name##pattern</i>}
             If <i>pattern</i> matches the beginning of the value of parameter <i>name</i>,
             the matched text is deleted from the result of substitution. A
             single '#' results in the shortest match, and two of them result
             in the longest match. Cannot be applied to a vector (${*} or ${@}
             or ${array[*]} or ${array[@]}).

     ${<i>name%pattern</i>}
     ${<i>name%%pattern</i>}
             Like ${...#...} substitution, but it deletes from the end of the
             value. Cannot be applied to a vector.

     ${<i>name/pattern/string</i>}
     ${<i>name/#pattern/string</i>}
     ${<i>name/%pattern/string</i>}
     ${<i>name//pattern/string</i>}
             The longest match of <i>pattern</i> in the value of parameter <i>name</i> is
             replaced with <i>string</i> (deleted if <i>string</i> is empty; the trailing
             slash ('/') may be omitted in that case). A leading slash fol-
             lowed by '#' or '%' causes the pattern to be anchored at the be-
             ginning or end of the value, respectively; empty unanchored
             <i>pattern</i>s cause no replacement; a single leading slash or use of a
             <i>pattern</i> that matches the empty string causes the replacement to
             happen only once; two leading slashes cause all occurrences of
             matches in the value to be replaced. Cannot be applied to a vec-
             tor. Inefficiently implemented, may be slow.

     ${<i>name@/pattern/string</i>}
             The same as ${<i>name//pattern/string</i>}, except that both <i>pattern</i> and
             <i>string</i> are expanded anew for each iteration.

     ${<i>name:pos:len</i>}
             The first <i>len</i> characters of <i>name</i>, starting at position <i>pos</i>, are
             substituted. Both <i>pos</i> and :<i>len</i> are optional. If <i>pos</i> is negative,
             counting starts at the end of the string; if it is omitted, it
             defaults to 0. If <i>len</i> is omitted or greater than the length of
             the remaining string, all of it is substituted. Both <i>pos</i> and <i>len</i>
             are evaluated as arithmetic expressions. Currently, <i>pos</i> must
             start with a space, opening parenthesis or digit to be recog-
             nised. Cannot be applied to a vector.

     ${<i>name</i>@#}
             The hash (using the BAFH algorithm) of the expansion of <i>name</i>.
             This is also used internally for the shell's hashtables.

     ${<i>name</i>@Q}
             A quoted expression safe for re-entry, whose value is the value
             of the <i>name</i> parameter, is substituted.

     Note that <i>pattern</i> may need extended globbing pattern (@(...)), single
     ('...') or double ("...") quote escaping unless <b>-o sh</b> is set.

     The following special parameters are implicitly set by the shell and can-
     not be set directly using assignments:

     !       Process ID of the last background process started. If no back-
             ground processes have been started, the parameter is not set.

     #       The number of positional parameters ($1, $2, etc.).

     $       The PID of the shell or, if it is a subshell, the PID of the ori-
             ginal shell. Do <i>NOT</i> use this mechanism for generating temporary
             file names; see mktemp(1) instead.

     -       The concatenation of the current single letter options (see the
             <b>set</b> command below for a list of options).

     ?       The exit status of the last non-asynchronous command executed. If
             the last command was killed by a signal, <b>$?</b> is set to 128 plus
             the signal number, but at most 255.

     0       The name of the shell, determined as follows: the first argument
             to <b>mksh</b> if it was invoked with the <b>-c</b> option and arguments were
             given; otherwise the <i>file</i> argument, if it was supplied; or else
             the basename the shell was invoked with (i.e. argv[0]). $0 is
             also set to the name of the current script or the name of the
             current function, if it was defined with the <b>function</b> keyword
             (i.e. a Korn shell style function).

     1 .. 9  The first nine positional parameters that were supplied to the
             shell, function, or script sourced using the "." built-in. Furth-
             er positional parameters may be accessed using ${<i>number</i>}.

     *       All positional parameters (except 0), i.e. $1, $2, $3, ...
             If used outside of double quotes, parameters are separate words
             (which are subjected to word splitting); if used within double
             quotes, parameters are separated by the first character of the
             IFS parameter (or the empty string if IFS is unset.

     @       Same as <b>$*</b>, unless it is used inside double quotes, in which case
             a separate word is generated for each positional parameter. If
             there are no positional parameters, no word is generated. <b>"$@"</b>
             can be used to access arguments, verbatim, without losing empty
             arguments or splitting arguments with spaces (IFS, actually).

     The following parameters are set and/or used by the shell:

     _            (underscore) When an external command is executed by the
                  shell, this parameter is set in the environment of the new
                  process to the path of the executed command. In interactive
                  use, this parameter is also set in the parent shell to the
                  last word of the previous command.

     BASHPID      The PID of the shell or subshell.

     CDPATH       Like PATH, but used to resolve the argument to the <b>cd</b>
                  built-in command. Note that if CDPATH is set and does not
                  contain "." or an empty string element, the current directo-
                  ry is not searched. Also, the <b>cd</b> built-in command will
                  display the resulting directory when a match is found in any
                  search path other than the empty path.

     COLUMNS      Set to the number of columns on the terminal or window. Al-
                  ways set, defaults to 80, unless the value as reported by
                  stty(1) is non-zero and sane enough (minimum is 12x3); simi-
                  lar for LINES. This parameter is used by the interactive
                  line editing modes and by the <b>select</b>, <b>set -o</b> and <b>kill -l</b>
                  commands to format information columns. Importing from the
                  environment or unsetting this parameter removes the binding
                  to the actual terminal size in favour of the provided value.

     ENV          If this parameter is found to be set after any profile files
                  are executed, the expanded value is used as a shell startup
                  file. It typically contains function and alias definitions.

     EPOCHREALTIME
                  Time since the epoch, as returned by gettimeofday(2), for-
                  matted as decimal <i>tv_sec</i> followed by a dot ('.') and <i>tv_usec</i>
                  padded to exactly six decimal digits.

     EXECSHELL    If set, this parameter is assumed to contain the shell that
                  is to be used to execute commands that execve(2) fails to
                  execute and which do not start with a "#!<i>shell</i>" sequence.

     FCEDIT       The editor used by the <b>fc</b> command (see below).

     FPATH        Like PATH, but used when an undefined function is executed
                  to locate the file defining the function. It is also
                  searched when a command can't be found using PATH. See
                  <i>Functions</i> below for more information.

     HISTFILE     The name of the file used to store command history. When as-
                  signed to or unset, the file is opened, history is truncated
                  then loaded from the file; subsequent new commands (possibly
                  consisting of several lines) are appended once they success-
                  fully compiled. Also, several invocations of the shell will
                  share history if their HISTFILE parameters all point to the
                  same file.

                  <b>Note</b>: If HISTFILE is unset or empty, no history file is
                  used. This is different from AT&#38;T UNIX <b>ksh</b>.

     HISTSIZE     The number of commands normally stored for history. The de-
                  fault is 2047. Do not set this value to insanely high values
                  such as 1000000000 because <b>mksh</b> can then not allocate enough
                  memory for the history and will not start.

     HOME         The default directory for the <b>cd</b> command and the value sub-
                  stituted for an unqualified <b>~</b> (see <i>Tilde expansion</i> below).

     IFS          Internal field separator, used during substitution and by
                  the <b>read</b> command, to split values into distinct arguments;
                  normally set to space, tab and newline. See <i>Substitution</i>
                  above for details.

                  <b>Note</b>: This parameter is not imported from the environment
                  when the shell is started.

     KSHEGID      The effective group id of the shell.

     KSHGID       The real group id of the shell.

     KSHUID       The real user id of the shell.

     KSH_MATCH    The last matched string. In a future version, this will be
                  an indexed array, with indexes 1 and up capturing matching
                  groups. Set by string comparisons (== and !=) in double-
                  bracket test expressions when a match is found (when != re-
                  turns false), by <b>case</b> when a match is encountered, and by
                  the substitution operations ${<i>x#pat</i>}, ${<i>x##pat</i>}, ${<i>x%pat</i>},
                  ${<i>x%%pat</i>}, ${<i>x/pat/rpl</i>}, ${<i>x/#pat/rpl</i>}, ${<i>x/%pat/rpl</i>},
                  ${<i>x//pat/rpl</i>}, and ${<i>x@/pat/rpl</i>}. See the end of the Emacs
                  editing mode documentation for an example.

     KSH_VERSION  The name and version of the shell (read-only). See also the
                  version commands in <i>Emacs editing mode</i> and <i>Vi editing mode</i>
                  sections, below.

     LINENO       The line number of the function or shell script that is
                  currently being executed.

     LINES        Set to the number of lines on the terminal or window. Always
                  set, defaults to 24. See COLUMNS.

     OLDPWD       The previous working directory. Unset if <b>cd</b> has not success-
                  fully changed directories since the shell started or if the
                  shell doesn't know where it is.

     OPTARG       When using <b>getopts</b>, it contains the argument for a parsed
                  option, if it requires one.

     OPTIND       The index of the next argument to be processed when using
                  <b>getopts</b>. Assigning 1 to this parameter causes <b>getopts</b> to
                  process arguments from the beginning the next time it is in-
                  voked.

     PATH         A colon (semicolon on OS/2) separated list of directories
                  that are searched when looking for commands and files
                  sourced using the "." command (see below). An empty string
                  resulting from a leading or trailing (semi)colon, or two ad-
                  jacent ones, is treated as a "." (the current directory).

     PATHSEP      A colon (semicolon on OS/2), for the user's convenience.

     PGRP         The process ID of the shell's process group leader.

     PIPESTATUS   An array containing the errorlevel (exit status) codes, one
                  by one, of the last pipeline run in the foreground.

     PPID         The process ID of the shell's parent.

     PS1          The primary prompt for interactive shells. Parameter, com-
                  mand and arithmetic substitutions are performed, and '!' is
                  replaced with the current command number (see the <b>fc</b> command
                  below). A literal '!' can be put in the prompt by placing
                  "!!" in PS1.

                  The default prompt is "$ " for non-root users, "# " for
                  root. If <b>mksh</b> is invoked by root and PS1 does not contain a
                  '#' character, the default value will be used even if PS1
                  already exists in the environment.

                  The <b>mksh</b> distribution comes with a sample <i>dot.mkshrc</i> con-
                  taining a sophisticated example, but you might like the fol-
                  lowing one (note that ${HOSTNAME:=$(hostname)} and the
                  root-vs-user distinguishing clause are (in this example) ex-
                  ecuted at PS1 assignment time, while the $USER and $PWD are
                  escaped and thus will be evaluated each time a prompt is
                  displayed):

                  PS1='${USER:=$(id -un)}'"@${HOSTNAME:=$(hostname)}:\$PWD $(
                          if (( USER_ID )); then print \$; else print \#; fi) "

                  Note that since the command-line editors try to figure out
                  how long the prompt is (so they know how far it is to the
                  edge of the screen), escape codes in the prompt tend to mess
                  things up. You can tell the shell not to count certain se-
                  quences (such as escape codes) by prefixing your prompt with
                  a character (such as Ctrl-A) followed by a carriage return
                  and then delimiting the escape codes with this character.
                  Any occurrences of that character in the prompt are not
                  printed. By the way, don't blame me for this hack; it's
                  derived from the original ksh88(1), which did print the del-
                  imiter character so you were out of luck if you did not have
                  any non-printing characters.

                  Since backslashes and other special characters may be inter-
                  preted by the shell, to set PS1 either escape the backslash
                  itself or use double quotes. The latter is more practical.
                  This is a more complex example, avoiding to directly enter
                  special characters (for example with <b>^V</b> in the emacs editing
                  mode), which embeds the current working directory, in re-
                  verse video (colour would work, too), in the prompt string:

                        x=$(print \\001) # otherwise unused char
                        PS1="$x$(print \\r)$x$(tput so)$x\$PWD$x$(tput se)$x&#62; "

                  Due to a strong suggestion from David G. Korn, <b>mksh</b> now also
                  supports the following form:

                        PS1=$'\1\r\1\e[7m\1$PWD\1\e[0m\1&#62; '

     PS2          Secondary prompt string, by default "&#62; ", used when more in-
                  put is needed to complete a command.

     PS3          Prompt used by the <b>select</b> statement when reading a menu
                  selection. The default is "#? ".

     PS4          Used to prefix commands that are printed during execution
                  tracing (see the <b>set -x</b> command below). Parameter, command
                  and arithmetic substitutions are performed before it is
                  printed. The default is "+ ". You may want to set it to
                  "[$EPOCHREALTIME] " instead, to include timestamps.

     PWD          The current working directory. May be unset or empty if the
                  shell doesn't know where it is.

     RANDOM       Each time RANDOM is referenced, it is assigned a number
                  between 0 and 32767 from a Linear Congruential PRNG first.

     REPLY        Default parameter for the <b>read</b> command if no names are
                  given. Also used in <b>select</b> loops to store the value that is
                  read from standard input.

     SECONDS      The number of seconds since the shell started or, if the
                  parameter has been assigned an integer value, the number of
                  seconds since the assignment plus the value that was as-
                  signed.

     TMOUT        If set to a positive integer in an interactive shell, it
                  specifies the maximum number of seconds the shell will wait
                  for input after printing the primary prompt (PS1). If the
                  time is exceeded, the shell exits.

     TMPDIR       The directory temporary shell files are created in. If this
                  parameter is not set or does not contain the absolute path
                  of a writable directory, temporary files are created in
                  <i>/tmp</i>.

     USER_ID      The effective user id of the shell.
</pre><h3>Tilde expansion</h3><pre>
     Tilde expansion, which is done in parallel with parameter substitution,
     is applied to words starting with an unquoted '~'. In parameter assign-
     ments (such as those preceding a simple-command or those occurring in the
     arguments of a declaration utility), tilde expansion is done after any
     assignment (i.e. after the equals sign) or after an unquoted colon (':');
     login names are also delimited by colons. The Korn shell, except in POSIX
     mode, always expands tildes after unquoted equals signs, not just in as-
     signment context (see below), and enables tab completion for tildes after
     all unquoted colons during command line editing.

     The characters following the tilde, up to the first '/', if any, are as-
     sumed to be a login name. If the login name is empty, '+' or '-', the
     simplified value of the HOME, PWD or OLDPWD parameter is substituted,
     respectively. Otherwise, the password file is searched for the login
     name, and the tilde expression is substituted with the user's home direc-
     tory. If the login name is not found in the password file or if any quot-
     ing or parameter substitution occurs in the login name, no substitution
     is performed.

     The home directory of previously expanded login names are cached and re-
     used. The <b>alias -d</b> command may be used to list, change and add to this
     cache (e.g. <b>alias -d fac=/usr/local/facilities; cd ~fac/bin)</b>.
</pre><h3>Brace expansion (alternation)</h3><pre>
     Brace expressions take the following form:

           <i>prefix</i>{<i>str1</i>,...,<i>strN</i>}<i>suffix</i>

     The expressions are expanded to <i>N</i> words, each of which is the concatena-
     tion of <i>prefix</i>, <i>str</i>i and <i>suffix</i> (e.g. "a{c,b{X,Y},d}e" expands to four
     words: "ace", "abXe", "abYe" and "ade"). As noted in the example, brace
     expressions can be nested and the resulting words are not sorted. Brace
     expressions must contain an unquoted comma (',') for expansion to occur
     (e.g. <b>{}</b> and <b>{foo}</b> are not expanded). Brace expansion is carried out
     after parameter substitution and before file name generation.
</pre><h3>File name patterns</h3><pre>
     A file name pattern is a word containing one or more unquoted '?', '*',
     '+', '@' or '!' characters or "[...]" sequences. Once brace expansion has
     been performed, the shell replaces file name patterns with the sorted
     names of all the files that match the pattern (if no files match, the
     word is left unchanged). The pattern elements have the following meaning:

     ?       Matches any single character.

     *       Matches any sequence of octets.

     [...]   Matches any of the octets inside the brackets. Ranges of octets
             can be specified by separating two octets by a '-' (e.g. "[a0-9]"
             matches the letter 'a' or any digit). In order to represent it-
             self, a '-' must either be quoted or the first or last octet in
             the octet list. Similarly, a ']' must be quoted or the first oc-
             tet in the list if it is to represent itself instead of the end
             of the list. Also, a '!' appearing at the start of the list has
             special meaning (see below), so to represent itself it must be
             quoted or appear later in the list.

     [!...]  Like [...], except it matches any octet not inside the brackets.

     *(<i>pattern</i>|...|<i>pattern</i>)
             Matches any string of octets that matches zero or more oc-
             currences of the specified patterns. Example: The pattern
             <b>*(foo</b>|<b>bar</b>) matches the strings "", "foo", "bar", "foobarfoo",
             etc.

     +(<i>pattern</i>|...|<i>pattern</i>)
             Matches any string of octets that matches one or more occurrences
             of the specified patterns. Example: The pattern <b>+(foo</b>|<b>bar)</b>
             matches the strings "foo", "bar", "foobar", etc.

     ?(<i>pattern</i>|...|<i>pattern</i>)
             Matches the empty string or a string that matches one of the
             specified patterns. Example: The pattern <b>?(foo</b>|<b>bar</b>) only matches
             the strings "", "foo" and "bar".

     @(<i>pattern</i>|...|<i>pattern</i>)
             Matches a string that matches one of the specified patterns. Ex-
             ample: The pattern <b>@(foo</b>|<b>bar</b>) only matches the strings "foo" and
             "bar".

     !(<i>pattern</i>|...|<i>pattern</i>)
             Matches any string that does not match one of the specified pat-
             terns. Examples: The pattern <b>!(foo</b>|<b>bar</b>) matches all strings ex-
             cept "foo" and "bar"; the pattern <b>!(*</b>) matches no strings; the
             pattern <b>!(?)*</b> matches all strings (think about it).

     Note that complicated globbing, especially with alternatives, is slow;
     using separate comparisons may (or may not) be faster.

     Note that <b>mksh</b> (and <b>pdksh</b>) never matches "." and "..", but AT&#38;T UNIX <b>ksh</b>,
     Bourne <b>sh</b> and GNU <b>bash</b> do.

     Note that none of the above pattern elements match either a period ('.')
     at the start of a file name or a slash ('/'), even if they are explicitly
     used in a [...] sequence; also, the names "." and ".." are never matched,
     even by the pattern ".*".

     If the <b>markdirs</b> option is set, any directories that result from file name
     generation are marked with a trailing '/'.
</pre><h3>Input/output redirection</h3><pre>
     When a command is executed, its standard input, standard output and stan-
     dard error (file descriptors 0, 1 and 2, respectively) are normally in-
     herited from the shell. Three exceptions to this are commands in pipe-
     lines, for which standard input and/or standard output are those set up
     by the pipeline, asynchronous commands created when job control is dis-
     abled, for which standard input is initially set to <i>/dev/null</i>, and com-
     mands for which any of the following redirections have been specified:

     &#62;<i>file</i>       Standard output is redirected to <i>file</i>. If <i>file</i> does not ex-
                 ist, it is created; if it does exist, is a regular file, and
                 the <b>noclobber</b> option is set, an error occurs; otherwise, the
                 file is truncated. Note that this means the command <b>cmd &#60;foo</b>
                 <b>&#62;foo</b> will open <i>foo</i> for reading and then truncate it when it
                 opens it for writing, before <i>cmd</i> gets a chance to actually
                 read <i>foo</i>.

     &#62;|<i>file</i>      Same as <b>&#62;</b>, except the file is truncated, even if the
                 <b>noclobber</b> option is set.

     &#62;&#62;<i>file</i>      Same as <b>&#62;</b>, except if <i>file</i> exists it is appended to instead of
                 being truncated. Also, the file is opened in append mode, so
                 writes always go to the end of the file (see open(2)).

     &#60;<i>file</i>       Standard input is redirected from <i>file</i>, which is opened for
                 reading.

     &#60;&#62;<i>file</i>      Same as <b>&#60;</b>, except the file is opened for reading and writing.

     &#60;&#60;<i>marker</i>    After reading the command line containing this kind of
                 redirection (called a "here document"), the shell copies
                 lines from the command source into a temporary file until a
                 line matching <i>marker</i> is read. When the command is executed,
                 standard input is redirected from the temporary file. If
                 <i>marker</i> contains no quoted characters, the contents of the
                 temporary file are processed as if enclosed in double quotes
                 each time the command is executed, so parameter, command and
                 arithmetic substitutions are performed, along with backslash
                 ('\') escapes for '$', '`', '\' and "\newline", but not for
                 '"'. If multiple here documents are used on the same command
                 line, they are saved in order.

                 If no <i>marker</i> is given, the here document ends at the next <b>&#60;&#60;</b>
                 and substitution will be performed. If <i>marker</i> is only a set
                 of either single "''" or double '""' quotes with nothing in
                 between, the here document ends at the next empty line and
                 substitution will not be performed.

     &#60;&#60;-<i>marker</i>   Same as <b>&#60;&#60;</b>, except leading tabs are stripped from lines in
                 the here document.

     &#60;&#60;&#60;<i>word</i>     Same as <b>&#60;&#60;</b>, except that <i>word is</i> the here document. This is
                 called a here string.

     &#60;&#38;<i>fd</i>        Standard input is duplicated from file descriptor <i>fd. fd</i> can
                 be a single digit, indicating the number of an existing file
                 descriptor; the letter 'p', indicating the file descriptor
                 associated with the output of the current co-process; or the
                 character '-', indicating standard input is to be closed.

     &#62;&#38;<i>fd</i>        Same as <b>&#60;&#38;</b>, except the operation is done on standard output.

     &#38;&#62;<i>file</i>      Same as <b>&#62;</b><i>file 2</i>&#62;&#38;<i>1</i>. This is a deprecated (legacy) GNU <b>bash</b>
                 extension supported by <b>mksh</b> which also supports the preceding
                 explicit fd digit, for example, <b>3&#38;&#62;</b><i>file</i> is the same as <b>3&#62;</b><i>file</i>
                 <i>2</i>&#62;&#38;<i>3</i> in <b>mksh</b> but a syntax error in GNU <b>bash</b>.

     &#38;&#62;|<i>file</i>, &#38;&#62;&#62;<i>file</i>, &#38;&#62;&#38;<i>fd</i>
                 Same as <b>&#62;</b>|<i>file</i>, <b>&#62;&#62;</b><i>file</i> or <b>&#62;&#38;</b><i>fd</i>, followed by <b>2&#62;&#38;1</b>, as above.
                 These are <b>mksh</b> extensions.

     In any of the above redirections, the file descriptor that is redirected
     (i.e. standard input or standard output) can be explicitly given by
     preceding the redirection with a single digit. Parameter, command and ar-
     ithmetic substitutions, tilde substitutions, and, if the shell is in-
     teractive, file name generation are all performed on the <i>file</i>, <i>marker</i> and
     <i>fd</i> arguments of redirections. Note, however, that the results of any file
     name generation are only used if a single file is matched; if multiple
     files match, the word with the expanded file name generation characters
     is used. Note that in restricted shells, redirections which can create
     files cannot be used.

     For simple-commands, redirections may appear anywhere in the command; for
     compound-commands (<b>if</b> statements, etc.), any redirections must appear at
     the end. Redirections are processed after pipelines are created and in
     the order they are given, so the following will print an error with a
     line number prepended to it:

           $ cat /foo/bar 2&#62;&#38;1 &#62;/dev/null | pr -n -t

     File descriptors created by I/O redirections are private to the shell.
</pre><h3>Arithmetic expressions</h3><pre>
     Integer arithmetic expressions can be used with the <b>let</b> command, inside
     $((...)) expressions, inside array references (e.g. <i>name</i>[<i>expr</i>]), as
     numeric arguments to the <b>test</b> command, and as the value of an assignment
     to an integer parameter. <i>Warning</i>: This also affects implicit conversion
     to integer, for example as done by the <b>let</b> command. <i>Never</i> use unchecked
     user input, e.g. from the environment, in an arithmetic context!

     Expressions are calculated using signed arithmetic and the <i>mksh_ari_t</i>
     type (a 32-bit signed integer), unless they begin with a sole '#' charac-
     ter, in which case they use <i>mksh_uari_t</i> (a 32-bit unsigned integer).

     Expressions may contain alpha-numeric parameter identifiers, array refer-
     ences and integer constants and may be combined with the following C
     operators (listed and grouped in increasing order of precedence):

     Unary operators:

           + - ! ~ ++ --

     Binary operators:

           ,
           = += -= *= /= %= &#60;&#60;= &#62;&#62;= ^&#60;= ^&#62;= &#38;= ^= |=
           ||
           &#38;&#38;
           |
           ^
           &#38;
           == !=
           &#60; &#60;= &#62; &#62;=
           &#60;&#60; &#62;&#62; ^&#60; ^&#62;
           + -
           * / %

     Ternary operators:

           ?: (precedence is immediately higher than assignment)

     Grouping operators:

           ( )

     Integer constants and expressions are calculated using an exactly 32-bit
     wide, signed or unsigned, type with silent wraparound on integer over-
     flow. Integer constants may be specified with arbitrary bases using the
     notation <i>base#number</i>, where <i>base</i> is a decimal integer specifying the base
     (up to 36), and <i>number</i> is a number in the specified base. Additionally,
     base-16 integers may be specified by prefixing them with "0x" (case-
     insensitive) in all forms of arithmetic expressions, except as numeric
     arguments to the <b>test</b> built-in utility. Prefixing numbers with a sole di-
     git zero ("0") does not cause interpretation as octal (except in POSIX
     mode, as required by the standard), as that's unsafe to do.

     As a special <b>mksh</b> extension, numbers to the base of one are treated as
     either (8-bit transparent) ASCII or Unicode codepoints, depending on the
     shell's <b>utf8-mode</b> flag (current setting). The AT&#38;T UNIX <b>ksh93</b> syntax of
     "'x'" instead of "1#x" is also supported. Note that NUL bytes (integral
     value of zero) cannot be used. An unset or empty parameter evaluates to 0
     in integer context. In Unicode mode, raw octets are mapped into the range
     EF80..EFFF as in OPTU-8, which is in the PUA and has been assigned by
     CSUR for this use. If more than one octet in ASCII mode, or a sequence of
     more than one octet not forming a valid and minimal CESU-8 sequence is
     passed, the behaviour is undefined (usually, the shell aborts with a
     parse error, but rarely, it succeeds, e.g. on the sequence C2 20). That's
     why you should always use ASCII mode unless you know that the input is
     well-formed UTF-8 in the range of 0000..FFFD if you use this feature, as
     opposed to <b>read -a</b>.

     The operators are evaluated as follows:

           unary +
                   Result is the argument (included for completeness).

           unary -
                   Negation.

           !       Logical NOT; the result is 1 if argument is zero, 0 if not.

           ~       Arithmetic (bit-wise) NOT.

           ++      Increment; must be applied to a parameter (not a literal or
                   other expression). The parameter is incremented by 1. When
                   used as a prefix operator, the result is the incremented
                   value of the parameter; when used as a postfix operator,
                   the result is the original value of the parameter.

           --      Similar to <b>++</b>, except the parameter is decremented by 1.

           ,       Separates two arithmetic expressions; the left-hand side is
                   evaluated first, then the right. The result is the value of
                   the expression on the right-hand side.

           =       Assignment; the variable on the left is set to the value on
                   the right.

           += -= *= /= %= &#60;&#60;= &#62;&#62;= ^&#60;= ^&#62;= &#38;= ^= |=
                   Assignment operators. &#60;<i>var</i>&#62;&#60;<i>op</i>&#62;=&#60;<i>expr</i>&#62; is the same as
                   &#60;<i>var</i>&#62;=&#60;<i>var</i>&#62;&#60;<i>op</i>&#62;&#60;<i>expr</i>&#62;, with any operator precedence in
                   &#60;<i>expr</i>&#62; preserved. For example, "var1 *= 5 + 3" is the same
                   as specifying "var1 = var1 * (5 + 3)".

           ||      Logical OR; the result is 1 if either argument is non-zero,
                   0 if not. The right argument is evaluated only if the left
                   argument is zero.

           &#38;&#38;      Logical AND; the result is 1 if both arguments are non-
                   zero, 0 if not. The right argument is evaluated only if the
                   left argument is non-zero.

           |       Arithmetic (bit-wise) OR.

           ^       Arithmetic (bit-wise) XOR (exclusive-OR).

           &#38;       Arithmetic (bit-wise) AND.

           ==      Equal; the result is 1 if both arguments are equal, 0 if
                   not.

           !=      Not equal; the result is 0 if both arguments are equal, 1
                   if not.

           &#60;       Less than; the result is 1 if the left argument is less
                   than the right, 0 if not.

           &#60;= &#62; &#62;=
                   Less than or equal, greater than, greater than or equal.
                   See <b>&#60;</b>.

           &#60;&#60; &#62;&#62;   Shift left (right); the result is the left argument with
                   its bits arithmetically (signed operation) or logically
                   (unsigned expression) shifted left (right) by the amount
                   given in the right argument.

           ^&#60; ^&#62;   Rotate left (right); the result is similar to shift, except
                   that the bits shifted out at one end are shifted in at the
                   other end, instead of zero or sign bits.

           + - * /
                   Addition, subtraction, multiplication and division.

           %       Remainder; the result is the symmetric remainder of the
                   division of the left argument by the right. To get the
                   mathematical modulus of "a <b>mod</b> b", use the formula
                   "(a % b + b) % b".

           &#60;<i>arg1</i>&#62;?&#60;<i>arg2</i>&#62;:&#60;<i>arg3</i>&#62;
                   If &#60;<i>arg1</i>&#62; is non-zero, the result is &#60;<i>arg2</i>&#62;; otherwise the
                   result is &#60;<i>arg3</i>&#62;. The non-result argument is not evaluated.
</pre><h3>Co-processes</h3><pre>
     A co-process (which is a pipeline created with the "|&#38;" operator) is an
     asynchronous process that the shell can both write to (using <b>print -p</b>)
     and read from (using <b>read -p)</b>. The input and output of the co-process can
     also be manipulated using <b>&#62;&#38;p</b> and <b>&#60;&#38;p</b> redirections, respectively. Once a
     co-process has been started, another can't be started until the co-
     process exits, or until the co-process's input has been redirected using
     an <b>exec</b> <i>n</i><b>&#62;&#38;p</b> redirection. If a co-process's input is redirected in this
     way, the next co-process to be started will share the output with the
     first co-process, unless the output of the initial co-process has been
     redirected using an <b>exec</b> <i>n</i><b>&#60;&#38;p</b> redirection.

     Some notes concerning co-processes:

     •   The only way to close the co-process's input (so the co-process reads
         an end-of-file) is to redirect the input to a numbered file descrip-
         tor and then close that file descriptor: <b>exec 3&#62;&#38;p; exec 3&#62;&#38;-</b>

     •   In order for co-processes to share a common output, the shell must
         keep the write portion of the output pipe open. This means that end-
         of-file will not be detected until all co-processes sharing the co-
         process's output have exited (when they all exit, the shell closes
         its copy of the pipe). This can be avoided by redirecting the output
         to a numbered file descriptor (as this also causes the shell to close
         its copy). Note that this behaviour is slightly different from the
         original Korn shell which closes its copy of the write portion of the
         co-process output when the most recently started co-process (instead
         of when all sharing co-processes) exits.

     •   <b>print -p</b> will ignore SIGPIPE signals during writes if the signal is
         not being trapped or ignored; the same is true if the co-process in-
         put has been duplicated to another file descriptor and <b>print -u</b><i>n</i> is
         used.
</pre><h3>Functions</h3><pre>
     Functions are defined using either Korn shell <b>function</b> <i>function-name</i> syn-
     tax or the Bourne/POSIX shell <i>function-name</i>() syntax (see below for the
     difference between the two forms). Functions are like .-scripts (i.e.
     scripts sourced using the "." built-in) in that they are executed in the
     current environment. However, unlike .-scripts, shell arguments (i.e. po-
     sitional parameters $1, $2, etc.) are never visible inside them. When the
     shell is determining the location of a command, functions are searched
     after special built-in commands, before builtins and the PATH is
     searched.

     An existing function may be deleted using <b>unset -f</b> <i>function-name</i>. A list
     of functions can be obtained using <b>typeset +f</b> and the function defini-
     tions can be listed using <b>typeset -f</b>. The <b>autoload</b> command (which is an
     alias for <b>typeset -fu</b>) may be used to create undefined functions: when an
     undefined function is executed, the shell searches the path specified in
     the FPATH parameter for a file with the same name as the function which,
     if found, is read and executed. If after executing the file the named
     function is found to be defined, the function is executed; otherwise, the
     normal command search is continued (i.e. the shell searches the regular
     built-in command table and PATH). Note that if a command is not found us-
     ing PATH, an attempt is made to autoload a function using FPATH (this is
     an undocumented feature of the original Korn shell).

     Functions can have two attributes, "trace" and "export", which can be set
     with <b>typeset -ft</b> and <b>typeset -fx</b>, respectively. When a traced function is
     executed, the shell's <b>xtrace</b> option is turned on for the function's dura-
     tion. The "export" attribute of functions is currently not used. In the
     original Korn shell, exported functions are visible to shell scripts that
     are executed.

     Since functions are executed in the current shell environment, parameter
     assignments made inside functions are visible after the function com-
     pletes. If this is not the desired effect, the <b>typeset</b> command can be
     used inside a function to create a local parameter. Note that AT&#38;T UNIX
     <b>ksh93</b> uses static scoping (one global scope, one local scope per func-
     tion) and allows local variables only on Korn style functions, whereas
     <b>mksh</b> uses dynamic scoping (nested scopes of varying locality). Note that
     special parameters (e.g. <b>$$</b>, <b>$!</b>) can't be scoped in this way.

     The exit status of a function is that of the last command executed in the
     function. A function can be made to finish immediately using the <b>return</b>
     command; this may also be used to explicitly specify the exit status.
     Note that when called in a subshell, <b>return</b> will only exit that subshell
     and will not cause the original shell to exit a running function (see the
     <b>while...read</b> loop FAQ below).

     Functions defined with the <b>function</b> reserved word are treated differently
     in the following ways from functions defined with the <b>(</b>) notation:

     •   The $0 parameter is set to the name of the function (Bourne-style
         functions leave $0 untouched).

     •   Parameter assignments preceding function calls are not kept in the
         shell environment (executing Bourne-style functions will keep assign-
         ments).

     •   OPTIND is saved/reset and restored on entry and exit from the func-
         tion so <b>getopts</b> can be used properly both inside and outside the
         function (Bourne-style functions leave OPTIND untouched, so using
         <b>getopts</b> inside a function interferes with using <b>getopts</b> outside the
         function).

     •   Shell options (<b>set -o</b>) have local scope, i.e. changes inside a func-
         tion are reset upon its exit.

     In the future, the following differences may also be added:

     •   A separate trap/signal environment will be used during the execution
         of functions. This will mean that traps set inside a function will
         not affect the shell's traps and signals that are not ignored in the
         shell (but may be trapped) will have their default effect in a func-
         tion.

     •   The EXIT trap, if set in a function, will be executed after the func-
         tion returns.
</pre><h3>Command execution</h3><pre>
     After evaluation of command-line arguments, redirections and parameter
     assignments, the type of command is determined: a special built-in com-
     mand, a function, a normal builtin or the name of a file to execute found
     using the PATH parameter. The checks are made in the above order. Special
     built-in commands differ from other commands in that the PATH parameter
     is not used to find them, an error during their execution can cause a
     non-interactive shell to exit, and parameter assignments that are speci-
     fied before the command are kept after the command completes. Regular
     built-in commands are different only in that the PATH parameter is not
     used to find them.

     The original <b>ksh</b> and POSIX differ somewhat in which commands are con-
     sidered special or regular.

     POSIX special built-in utilities:

     <b>.</b>, <b>:</b>, <b>break</b>, <b>continue</b>, <b>eval</b>, <b>exec</b>, <b>exit</b>, <b>export</b>, <b>readonly</b>, <b>return</b>, <b>set</b>,
     <b>shift</b>, <b>times</b>, <b>trap</b>, <b>unset</b>

     Additional <b>mksh</b> commands keeping assignments:

     <b>global</b>, <b>source</b>, <b>typeset</b>

     Builtins that are not special:

     [, <b>alias</b>, <b>bg</b>, <b>bind</b>, <b>builtin</b>, <b>cat</b>, <b>cd</b>, <b>command</b>, <b>echo</b>, <b>false</b>, <b>fc</b>, <b>fg</b>,
     <b>getopts</b>, <b>jobs</b>, <b>kill</b>, <b>let</b>, <b>print</b>, <b>pwd</b>, <b>read</b>, <b>realpath</b>, <b>rename</b>, <b>sleep</b>,
     <b>suspend</b>, <b>test</b>, <b>true</b>, <b>ulimit</b>, <b>umask</b>, <b>unalias</b>, <b>wait</b>, <b>whence</b>

     Once the type of command has been determined, any command-line parameter
     assignments are performed and exported for the duration of the command.

     The following describes the special and regular built-in commands and
     builtin-like reserved words:

     <b>.</b> <i>file</i> [<i>arg</i> ...]
            This is called the "dot" command. Execute the commands in <i>file</i> in
            the current environment. The file is searched for in the direc-
            tories of PATH. If arguments are given, the positional parameters
            may be used to access them while <i>file</i> is being executed. If no ar-
            guments are given, the positional parameters are those of the en-
            vironment the command is used in.

     <b>:</b> [...]
            The null command. Exit status is set to zero.

     <b>[</b> <i>expression</i> <b>]</b>
            See <b>test</b>.

     <b>alias</b> [<b>-d</b> | <b>-t</b> [<b>-r</b>] | <b>+-x</b>] [<b>-p</b>] [<b>+</b>] [<i>name</i>[=<i>value</i>] ...]
            Without arguments, <b>alias</b> lists all aliases. For any name without a
            value, the existing alias is listed. Any name with a value defines
            an alias; see <i>Aliases</i> above. [][A-Za-z0-9_!%,.@:-] are valid in
            names, except they may not begin with a hyphen-minus, and <b>[[</b> is
            not a valid alias name.

            When listing aliases, one of two formats is used. Normally,
            aliases are listed as <i>name</i>=<i>value</i>, where <i>value</i> is quoted. If op-
            tions were preceded with '+', or a lone '+' is given on the com-
            mand line, only <i>name</i> is printed.

            The <b>-d</b> option causes directory aliases which are used in tilde ex-
            pansion to be listed or set (see <i>Tilde expansion</i> above).

            If the <b>-p</b> option is used, each alias is prefixed with the string
            "alias ".

            The <b>-t</b> option indicates that tracked aliases are to be listed/set
            (values specified on the command line are ignored for tracked
            aliases). The <b>-r</b> option indicates that all tracked aliases are to
            be reset.

            The <b>-x</b> option sets (<b>+x</b> clears) the export attribute of an alias,
            or, if no names are given, lists the aliases with the export at-
            tribute (exporting an alias has no effect).

     <b>bg</b> [<i>job</i> ...]
            Resume the specified stopped job(s) in the background. If no jobs
            are specified, <b>%+</b> is assumed. See <i>Job control</i> below for more in-
            formation.

     <b>bind</b> [<b>-l</b>]
            The current bindings are listed. If the <b>-l</b> flag is given, <b>bind</b> in-
            stead lists the names of the functions to which keys may be bound.
            See <i>Emacs editing mode</i> for more information.

     <b>bind</b> [<b>-m</b>] <i>string</i>=[<i>substitute</i>] ...
     <b>bind</b> <i>string</i>=[<i>editing-command</i>] ...
            The specified editing command is bound to the given <i>string</i>, which
            should consist of a control character optionally preceded by one
            of the two prefix characters and optionally succeeded by a tilde
            character. Future input of the <i>string</i> will cause the editing com-
            mand to be immediately invoked. If the <b>-m</b> flag is given, the
            specified input <i>string</i> will afterwards be immediately replaced by
            the given <i>substitute</i> string which may contain editing commands but
            not other macros. If a tilde postfix is given, a tilde trailing
            the one or two prefices and the control character is ignored, any
            other trailing character will be processed afterwards.

            Control characters may be written using caret notation i.e. ^X
            represents Ctrl-X. The caret itself can be escaped by a backslash,
            which also escapes itself. Note that although only three prefix
            characters (usually ESC, ^X and NUL) are supported, some multi-
            character sequences can be supported.

            The following default bindings show how the arrow keys, the home,
            end and delete key on a BSD wsvt25, xterm-xfree86 or GNU screen
            terminal are bound (of course some escape sequences won't work out
            quite this nicely):

                  bind '^X'=prefix-2
                  bind '^[['=prefix-2
                  bind '^XA'=up-history
                  bind '^XB'=down-history
                  bind '^XC'=forward-char
                  bind '^XD'=backward-char
                  bind '^X1~'=beginning-of-line
                  bind '^X7~'=beginning-of-line
                  bind '^XH'=beginning-of-line
                  bind '^X4~'=end-of-line
                  bind '^X8~'=end-of-line
                  bind '^XF'=end-of-line
                  bind '^X3~'=delete-char-forward

     <b>break</b> [<i>level</i>]
            Exit the <i>level</i>th inner-most <b>for</b>, <b>select</b>, <b>until</b> or <b>while</b> loop.
            <i>level</i> defaults to 1.

     <b>builtin</b> [<b>--</b>] <i>command</i> [<i>arg</i> ...]
            Execute the built-in command <i>command</i>.

     <b>\builtin</b> <i>command</i> [<i>arg</i> ...]
            Same as <b>builtin</b>. Additionally acts as declaration utility forward-
            er, i.e. this is a declaration utility (see <i>Tilde expansion</i>) iff
            <i>command</i> is a declaration utility.

     <b>cat</b> [<b>-u</b>] [<i>file</i> ...]
            Read files sequentially, in command line order, and write them to
            standard output. If a <i>file</i> is a single dash ("-") or absent, read
            from standard input. For direct builtin calls, the POSIX <b>-u</b> option
            is supported as a no-op. For calls from shell, if any options are
            given, an external cat(1) utility is preferred over the builtin.

     <b>cd</b> [<b>-L</b>] [<i>dir</i>]
     <b>cd -P</b> [<b>-e</b>] [<i>dir</i>]
     <b>chdir</b> [<b>-eLP</b>] [<i>dir</i>]
            Set the working directory to <i>dir</i>. If the parameter CDPATH is set,
            it lists the search path for the directory containing <i>dir</i>. An un-
            set or empty path means the current directory. If <i>dir</i> is found in
            any component of the CDPATH search path other than an unset or
            empty path, the name of the new working directory will be written
            to standard output. If <i>dir</i> is missing, the home directory HOME is
            used. If <i>dir</i> is "-", the previous working directory is used (see
            the OLDPWD parameter).

            If the <b>-L</b> option (logical path) is used or if the <b>physical</b> option
            isn't set (see the <b>set</b> command below), references to ".." in <i>dir</i>
            are relative to the path used to get to the directory. If the <b>-P</b>
            option (physical path) is used or if the <b>physical</b> option is set,
            ".." is relative to the filesystem directory tree. The PWD and
            OLDPWD parameters are updated to reflect the current and old work-
            ing directory, respectively. If the <b>-e</b> option is set for physical
            filesystem traversal and PWD could not be set, the exit code is 1;
            greater than 1 if an error occurred, 0 otherwise.

     <b>cd</b> [<b>-eLP</b>] <i>old new</i>
     <b>chdir</b> [<b>-eLP</b>] <i>old new</i>
            The string <i>new</i> is substituted for <i>old</i> in the current directory,
            and the shell attempts to change to the new directory.

     <b>command</b> [<b>-pVv</b>] <i>cmd</i> [<i>arg</i> ...]
            If neither the <b>-v</b> nor <b>-V</b> option is given, <i>cmd</i> is executed exactly
            as if <b>command</b> had not been specified, with two exceptions: first-
            ly, <i>cmd</i> cannot be a shell function; and secondly, special built-in
            commands lose their specialness (i.e. redirection and utility er-
            rors do not cause the shell to exit, and command assignments are
            not permanent). The declaration utility property is not reset.

            If the <b>-p</b> option is given, a default search path is used instead
            of the current value of PATH, the actual value of which is system
            dependent.

            If the <b>-v</b> option is given, instead of executing <i>cmd</i>, information
            about what would be executed is given (and the same is done for
            <i>arg</i> ...). For builtins, functions and keywords, their names are
            simply printed; for aliases, a command that defines them is print-
            ed; for utilities found by searching the PATH parameter, the full
            path of the command is printed. If no command is found (i.e. the
            path search fails), nothing is printed and <b>command</b> exits with a
            non-zero status. The <b>-V</b> option is like the <b>-v</b> option, except it is
            more verbose.

     <b>continue</b> [<i>level</i>]
            Jumps to the beginning of the <i>level</i>th inner-most <b>for</b>, <b>select</b>,
            <b>until</b> or <b>while</b> loop. <i>level</i> defaults to 1.

     <b>echo</b> [<b>-Een</b>] [<i>arg</i> ...]
            <i>Warning</i>: this utility is not portable; use the Korn shell builtin
            <b>print</b> instead.

            Prints its arguments (separated by spaces) followed by a newline,
            to the standard output. The newline is suppressed if any of the
            arguments contain the backslash sequence "\c". See the <b>print</b> com-
            mand below for a list of other backslash sequences that are recog-
            nised.

            The options are provided for compatibility with BSD shell scripts.
            The <b>-n</b> option suppresses the trailing newline, <b>-e</b> enables
            backslash interpretation (a no-op, since this is normally done),
            and <b>-E</b> suppresses backslash interpretation.

            If the <b>posix</b> or <b>sh</b> option is set or this is a direct builtin call
            or <b>print -R</b>, only the first argument is treated as an option, and
            only if it is exactly "-n". Backslash interpretation is disabled.

     <b>eval</b> <i>command</i> ...
            The arguments are concatenated (with spaces between them) to form
            a single string which the shell then parses and executes in the
            current environment.

     <b>exec</b> [<b>-a</b> <i>argv0</i>] [<b>-c</b>] [<i>command</i> [<i>arg</i> ...]]
            The command is executed without forking, replacing the shell pro-
            cess. This is currently absolute, i.e. <b>exec</b> never returns, even if
            the <i>command</i> is not found. The <b>-a</b> option permits setting a dif-
            ferent argv[0] value, and <b>-c</b> clears the environment before execut-
            ing the child process, except for the _ variable and direct as-
            signments.

            If no command is given except for I/O redirection, the I/O
            redirection is permanent and the shell is not replaced. Any file
            descriptors greater than 2 which are opened or dup(2)'d in this
            way are not made available to other executed commands (i.e. com-
            mands that are not built-in to the shell). Note that the Bourne
            shell differs here; it does pass these file descriptors on.

     <b>exit</b> [<i>status</i>]
            The shell or subshell exits with the specified exit status. If
            <i>status</i> is not specified, the exit status is the current value of
            the <b>$?</b> parameter.

     <b>export</b> [<b>-p</b>] [<i>parameter</i>[=<i>value</i>]]
            Sets the export attribute of the named parameters. Exported param-
            eters are passed in the environment to executed commands. If
            values are specified, the named parameters are also assigned. This
            is a declaration utility.

            If no parameters are specified, all parameters with the export at-
            tribute set are printed one per line; either their names, or, if a
            "-" with no option letter is specified, name=value pairs, or, with
            <b>-p</b>, <b>export</b> commands suitable for re-entry.

     <b>false</b>  A command that exits with a non-zero status.

     <b>fc</b> [<b>-e</b> <i>editor</i> | <b>-l</b> [<b>-n</b>]] [<b>-r</b>] [<i>first</i> [<i>last</i>]]
            <i>first</i> and <i>last</i> select commands from the history. Commands can be
            selected by history number (negative numbers go backwards from the
            current, most recent, line) or a string specifying the most recent
            command starting with that string. The <b>-l</b> option lists the command
            on standard output, and <b>-n</b> inhibits the default command numbers.
            The <b>-r</b> option reverses the order of the list. Without <b>-l</b>, the
            selected commands are edited by the editor specified with the <b>-e</b>
            option or, if no <b>-e</b> is specified, the editor specified by the
            FCEDIT parameter (if this parameter is not set, <i>/bin/ed</i> is used),
            and then executed by the shell.

     <b>fc -e -</b> | <b>-s</b> [<b>-g</b>] [<i>old</i>=<i>new</i>] [<i>prefix</i>]
            Re-execute the selected command (the previous command by default)
            after performing the optional substitution of <i>old</i> with <i>new</i>. If <b>-g</b>
            is specified, all occurrences of <i>old</i> are replaced with <i>new</i>. The
            meaning of <b>-e -</b> and <b>-s</b> is identical: re-execute the selected com-
            mand without invoking an editor. This command is usually accessed
            with the predefined: <b>alias r='fc -e -'</b>

     <b>fg</b> [<i>job</i> ...]
            Resume the specified job(s) in the foreground. If no jobs are
            specified, <b>%+</b> is assumed. See <i>Job control</i> below for more informa-
            tion.

     <b>getopts</b> <i>optstring name</i> [<i>arg</i> ...]
            Used by shell procedures to parse the specified arguments (or po-
            sitional parameters, if no arguments are given) and to check for
            legal options. <i>optstring</i> contains the option letters that <b>getopts</b>
            is to recognise. If a letter is followed by a colon, the option is
            expected to have an argument. Options that do not take arguments
            may be grouped in a single argument. If an option takes an argu-
            ment and the option character is not the last character of the ar-
            gument it is found in, the remainder of the argument is taken to
            be the option's argument; otherwise, the next argument is the
            option's argument.

            Each time <b>getopts</b> is invoked, it places the next option in the
            shell parameter <i>name</i> and the index of the argument to be processed
            by the next call to <b>getopts</b> in the shell parameter OPTIND. If the
            option was introduced with a '+', the option placed in <i>name</i> is
            prefixed with a '+'. When an option requires an argument, <b>getopts</b>
            places it in the shell parameter OPTARG.

            When an illegal option or a missing option argument is encoun-
            tered, a question mark or a colon is placed in <i>name</i> (indicating an
            illegal option or missing argument, respectively) and OPTARG is
            set to the option character that caused the problem. Furthermore,
            if <i>optstring</i> does not begin with a colon, a question mark is
            placed in <i>name</i>, OPTARG is unset, and an error message is printed
            to standard error.

            When the end of the options is encountered, <b>getopts</b> exits with a
            non-zero exit status. Options end at the first (non-option argu-
            ment) argument that does not start with a '-', or when a "--" ar-
            gument is encountered.

            Option parsing can be reset by setting OPTIND to 1 (this is done
            automatically whenever the shell or a shell procedure is invoked).

            Warning: Changing the value of the shell parameter OPTIND to a
            value other than 1 or parsing different sets of arguments without
            resetting OPTIND may lead to unexpected results.

     <b>global</b> [<b>+-aglpnrtUux</b>] [<b>-L</b>[<i>n</i>] | <b>-R</b>[<i>n</i>] | <b>-Z</b>[<i>n</i>]] [<b>-i</b>[<i>n</i>]] [<i>name</i>[=<i>value</i>] ...]
            See <b>typeset -g</b>. Deprecated, <i>will</i> be removed from a future version
            of <b>mksh</b>.

     <b>hash</b> [<b>-r</b>] [<i>name</i> ...]
            Without arguments, any hashed executable command pathnames are
            listed. The <b>-r</b> option causes all hashed commands to be removed
            from the hash table. Each <i>name</i> is searched as if it were a command
            name and added to the hash table if it is an executable command.

     <b>jobs</b> [<b>-lnp</b>] [<i>job</i> ...]
            Display information about the specified job(s); if no jobs are
            specified, all jobs are displayed. The <b>-n</b> option causes informa-
            tion to be displayed only for jobs that have changed state since
            the last notification. If the <b>-l</b> option is used, the process ID of
            each process in a job is also listed. The <b>-p</b> option causes only
            the process group of each job to be printed. See <i>Job control</i> below
            for the format of <i>job</i> and the displayed job.

     <b>kill</b> [<b>-s</b> <i>signame</i> | <i>-signum</i> | <i>-signame</i>] { <i>job</i> | <i>pid</i> | <i>pgrp</i> } ...
            Send the specified signal to the specified jobs, process IDs or
            process groups. If no signal is specified, the TERM signal is
            sent. If a job is specified, the signal is sent to the job's pro-
            cess group. See <i>Job control</i> below for the format of <i>job</i>.

     <b>kill -l</b> [<i>exit-status</i> ...]
            Print the signal name corresponding to <i>exit-status</i>. If no argu-
            ments are specified, a list of all the signals with their numbers
            and a short description of each are printed.

     <b>let</b> [<i>expression</i> ...]
            Each expression is evaluated (see <i>Arithmetic expressions</i> above).
            If all expressions are successfully evaluated, the exit status is
            0 (1) if the last expression evaluated to non-zero (zero). If an
            error occurs during the parsing or evaluation of an expression,
            the exit status is greater than 1. Since expressions may need to
            be quoted, (( <i>expr</i> )) is syntactic sugar for:
                  { \\builtin let '<i>expr</i>'; }

     <b>mknod</b> [<b>-m</b> <i>mode</i>] <i>name</i> <b>b</b>|<b>c</b> <i>major minor</i>
     <b>mknod</b> [<b>-m</b> <i>mode</i>] <i>name</i> <b>p</b>
            Create a device special file. The file type may be <b>b</b> (block type
            device), <b>c</b> (character type device) or <b>p</b> (named pipe, FIFO). The
            file created may be modified according to its <i>mode</i> (via the <b>-m</b> op-
            tion), <i>major</i> (major device number), and <i>minor</i> (minor device
            number). This is not normally part of <b>mksh</b>; however, distributors
            may have added this as builtin as a speed hack.

     <b>print</b> [<b>-AcelNnprsu</b>[<i>n</i>] | <b>-R</b> [<b>-n</b>]] [<i>argument</i> ...]
            Print the specified argument(s) on the standard output, separated
            by spaces, terminated with a newline. The escapes mentioned in
            <i>Backslash expansion</i> above, as well as "\c", which is equivalent to
            using the <b>-n</b> option, are interpreted.

            The options are as follows:

            <b>-A</b>      Each <i>argument</i> is arithmetically evaluated; the character
                    corresponding to the resulting value is printed. Empty
                    <i>argument</i>s separate input words.

            <b>-c</b>      The output is printed columnised, line by line, similar to
                    how the rs(1) utility, tab completion, the <b>kill -l</b> built-
                    in utility and the <b>select</b> statement do.

            <b>-e</b>      Restore backslash expansion after a previous <b>-r</b>.

            <b>-l</b>      Change the output word separator to newline.

            <b>-N</b>      Change the output word and line separator to ASCII NUL.

            <b>-n</b>      Do not print the trailing line separator.

            <b>-p</b>      Print to the co-process (see <i>Co-processes</i> above).

            <b>-r</b>      Inhibit backslash expansion.

            <b>-s</b>      Print to the history file instead of standard output.

            <b>-u</b>[<i>n</i>]   Print to the file descriptor <i>n</i> (defaults to 1 if omitted)
                    instead of standard output.

            The <b>-R</b> option mostly emulates the BSD echo(1) command which does
            not expand backslashes and interprets its first argument as option
            only if it is exactly "-n" (to suppress the trailing newline).

     <b>pwd</b> [<b>-LP</b>]
            Print the present working directory. If the <b>-L</b> option is used or
            if the <b>physical</b> option isn't set (see the <b>set</b> command below), the
            logical path is printed (i.e. the path used to <b>cd</b> to the current
            directory). If the <b>-P</b> option (physical path) is used or if the
            <b>physical</b> option is set, the path determined from the filesystem
            (by following ".." directories to the root directory) is printed.

     <b>read</b> [<b>-A</b> | <b>-a</b>] [<b>-d</b> <i>x</i>] [<b>-N</b> <i>z</i> | <b>-n</b> <i>z</i>] [<b>-p</b> | <b>-u</b>[<i>n</i>]] [<b>-t</b> <i>n</i>] [<b>-rs</b>] [<i>p</i> ...]
            Reads a line of input, separates the input into fields using the
            IFS parameter (see <i>Substitution</i> above), and assigns each field to
            the specified parameters <i>p</i>. If no parameters are specified, the
            REPLY parameter is used to store the result. With the <b>-A</b> and <b>-a</b>
            options, only no or one parameter is accepted. If there are more
            parameters than fields, the extra parameters are set to the empty
            string or 0; if there are more fields than parameters, the last
            parameter is assigned the remaining fields (including the word
            separators).

            The options are as follows:

            <b>-A</b>     Store the result into the parameter <i>p</i> (or REPLY) as array
                   of words.

            <b>-a</b>     Store the result without word splitting into the parameter
                   <i>p</i> (or REPLY) as array of characters (wide characters if the
                   <b>utf8-mode</b> option is enacted, octets otherwise); the
                   codepoints are encoded as decimal numbers by default.

            <b>-d</b> <i>x</i>   Use the first byte of <i>x</i>, NUL if empty, instead of the ASCII
                   newline character as input line delimiter.

            <b>-N</b> <i>z</i>   Instead of reading till end-of-line, read exactly <i>z</i> bytes.
                   Upon EOF, a partial read is returned with exit status 1.
                   After timeout, a partial read is returned with an exit
                   status as if SIGALRM were caught.

            <b>-n</b> <i>z</i>   Instead of reading till end-of-line, read up to <i>z</i> bytes but
                   return as soon as any bytes are read, e.g. from a slow ter-
                   minal device, or if EOF or a timeout occurs.

            <b>-p</b>     Read from the currently active co-process, see <i>Co-processes</i>
                   above for details on this.

            <b>-u</b>[<i>n</i>]  Read from the file descriptor <i>n</i> (defaults to 0, i.e. stan-
                   dard input). The argument must immediately follow the op-
                   tion character.

            <b>-t</b> <i>n</i>   Interrupt reading after <i>n</i> seconds (specified as positive
                   decimal value with an optional fractional part). The exit
                   status of <b>read</b> is the same as if SIGALRM were caught if the
                   timeout occurred, but partial reads may still be returned.

            <b>-r</b>     Normally, the ASCII backslash character escapes the special
                   meaning of the following character and is stripped from the
                   input; <b>read</b> does not stop when encountering a backslash-
                   newline sequence and does not store that newline in the
                   result. This option enables raw mode, in which backslashes
                   are not processed.

            <b>-s</b>     The input line is saved to the history.

            If the input is a terminal, both the <b>-N</b> and <b>-n</b> options set it into
            raw mode; they read an entire file if -1 is passed as <i>z</i> argument.

            The first parameter may have a question mark and a string appended
            to it, in which case the string is used as a prompt (printed to
            standard error before any input is read) if the input is a tty(4)
            (e.g. <b>read nfoo?'number of foos: ')</b>.

            If no input is read or a timeout occurred, <b>read</b> exits with a non-
            zero status.

     <b>readonly</b> [<b>-p</b>] [<i>parameter</i>[=<i>value</i>] ...]
            Sets the read-only attribute of the named parameters. This is a
            declaration utility. If values are given, parameters are set to
            them before setting the attribute. Once a parameter is made read-
            only, it cannot be unset and its value cannot be changed.

            If no parameters are specified, the names of all parameters with
            the read-only attribute are printed one per line, unless the <b>-p</b>
            option is used, in which case <b>readonly</b> commands defining all
            read-only parameters, including their values, are printed.

     <b>realpath</b> [<b>--</b>] <i>name</i>
            Prints the resolved absolute pathname corresponding to <i>name</i>. If
            <i>name</i> ends with a slash ('/'), it's also checked for existence and
            whether it is a directory; otherwise, <b>realpath</b> returns 0 if the
            pathname either exists or can be created immediately, i.e. all but
            the last component exist and are directories. For calls from the
            shell, if any options are given, an external realpath(1) utility
            is preferred over the builtin.

     <b>rename</b> [<b>--</b>] <i>from to</i>
            Renames the file <i>from</i> to <i>to</i>. Both must be complete pathnames and
            on the same device. An external utility is preferred over this
            builtin, which is intended for emergency situations (where <i>/bin/mv</i>
            becomes unusable) and directly calls rename(2).

     <b>return</b> [<i>status</i>]
            Returns from a function or <b>.</b> script, with exit status <i>status</i>. If
            no <i>status</i> is given, the exit status of the last executed command
            is used. If used outside of a function or <b>.</b> script, it has the
            same effect as <b>exit</b>. Note that <b>mksh</b> treats both profile and ENV
            files as <b>.</b> scripts, while the original Korn shell only treats pro-
            files as <b>.</b> scripts.

     <b>set</b> [<b>+-abCefhiklmnprsUuvXx</b>] [<b>+-o</b> <i>option</i>] [<b>+-A</b> <i>name</i>] [<b>--</b>] [<i>arg</i> ...]
            The <b>set</b> command can be used to set (<b>-</b>) or clear (<b>+</b>) shell options,
            set the positional parameters, or set an array parameter. Options
            can be changed using the <b>+-o</b> <i>option</i> syntax, where <i>option</i> is the
            long name of an option, or using the <b>+-</b><i>letter</i> syntax, where <i>letter</i>
            is the option's single letter name (not all options have a single
            letter name). The following table lists both option letters (if
            they exist) and long names along with a description of what the
            option does:

            <b>-A</b> <i>name</i>
                 Sets the elements of the array parameter <i>name</i> to <i>arg</i> ... If
                 <b>-A</b> is used, the array is reset (i.e. emptied) first; if <b>+A</b> is
                 used, the first N elements are set (where N is the number of
                 arguments); the rest are left untouched.

                 An alternative syntax for the command <b>set -A foo -- a b c</b>
                 which is compatible to GNU <b>bash</b> and also supported by AT&#38;T
                 UNIX <b>ksh93</b> is: <b>foo=(a b c); foo+=(d e)</b>

            <b>-a</b> | <b>-o allexport</b>
                 All new parameters are created with the export attribute.

            <b>-b</b> | <b>-o notify</b>
                 Print job notification messages asynchronously, instead of
                 just before the prompt. Only used if job control is enabled
                 (<b>-m)</b>.

            <b>-C</b> | <b>-o noclobber</b>
                 Prevent &#62; redirection from overwriting existing files. In-
                 stead, &#62;| must be used to force an overwrite. Note that this
                 is not safe to use for creation of temporary files or lock-
                 files due to a TOCTOU in a check allowing one to redirect
                 output to <i>/dev/null</i> or other device files even in <b>noclobber</b>
                 mode.

            <b>-e</b> | <b>-o errexit</b>
                 Exit (after executing the ERR trap) as soon as an error oc-
                 curs or a command fails (i.e. exits with a non-zero status).
                 This does not apply to commands whose exit status is expli-
                 citly tested by a shell construct such as <b>if</b>, <b>until</b>, <b>while</b> or
                 <b>!</b> statements. For <b>&#38;&#38;</b> or ||, only the status of the last com-
                 mand is tested.

            <b>-f</b> | <b>-o noglob</b>
                 Do not expand file name patterns.

            <b>-h</b> | <b>-o trackall</b>
                 Create tracked aliases for all executed commands (see <i>Aliases</i>
                 above). Enabled by default for non-interactive shells.

            <b>-i</b> | <b>-o interactive</b>
                 The shell is an interactive shell. This option can only be
                 used when the shell is invoked. See above for a description
                 of what this means.

            <b>-k</b> | <b>-o keyword</b>
                 Parameter assignments are recognised anywhere in a command.

            <b>-l</b> | <b>-o login</b>
                 The shell is a login shell. This option can only be used when
                 the shell is invoked. See above for a description of what
                 this means.

            <b>-m</b> | <b>-o monitor</b>
                 Enable job control (default for interactive shells).

            <b>-n</b> | <b>-o noexec</b>
                 Do not execute any commands. Useful for checking the syntax
                 of scripts (ignored if interactive).

            <b>-p</b> | <b>-o privileged</b>
                 The shell is a privileged shell. It is set automatically if,
                 when the shell starts, the real UID or GID does not match the
                 effective UID (EUID) or GID (EGID), respectively. See above
                 for a description of what this means.

            <b>-r</b> | <b>-o restricted</b>
                 The shell is a restricted shell. This option can only be used
                 when the shell is invoked. See above for a description of
                 what this means.

            <b>-s</b> | <b>-o stdin</b>
                 If used when the shell is invoked, commands are read from
                 standard input. Set automatically if the shell is invoked
                 with no arguments.

                 When <b>-s</b> is used with the <b>set</b> command it causes the specified
                 arguments to be sorted before assigning them to the position-
                 al parameters (or to array <i>name</i>, if <b>-A</b> is used).

            <b>-U</b> | <b>-o utf8-mode</b>
                 Enable UTF-8 support in the <i>Emacs editing mode</i> and internal
                 string handling functions. This flag is disabled by default,
                 but can be enabled by setting it on the shell command line;
                 is enabled automatically for interactive shells if requested
                 at compile time, your system supports <b>setlocale</b>(<i>LC_CTYPE</i>, "")
                 and optionally <b>nl_langinfo</b>(<i>CODESET)</i>, or the LC_ALL, LC_CTYPE
                 or LANG environment variables, and at least one of these re-
                 turns something that matches "UTF-8" or "utf8" case-
                 insensitively; for direct builtin calls depending on the
                 aforementioned environment variables; or for stdin or
                 scripts, if the input begins with a UTF-8 Byte Order Mark.

                 In near future, locale tracking will be implemented, which
                 means that <b>set -+U</b> is changed whenever one of the POSIX
                 locale-related environment variables changes.

            <b>-u</b> | <b>-o nounset</b>
                 Referencing of an unset parameter, other than "$@" or "$*",
                 is treated as an error, unless one of the '-', '+' or '='
                 modifiers is used.

            <b>-v</b> | <b>-o verbose</b>
                 Write shell input to standard error as it is read.

            <b>-X</b> | <b>-o markdirs</b>
                 Mark directories with a trailing '/' during file name genera-
                 tion.

            <b>-x</b> | <b>-o xtrace</b>
                 Print command trees when they are executed, preceded by the
                 value of PS4.

            <b>-o bgnice</b>
                 Background jobs are run with lower priority.

            <b>-o braceexpand</b>
                 Enable brace expansion (a.k.a. alternation). This is enabled
                 by default.

            <b>-o emacs</b>
                 Enable BRL emacs-like command-line editing (interactive
                 shells only); see <i>Emacs editing mode</i>.

            <b>-o gmacs</b>
                 Enable gmacs-like command-line editing (interactive shells
                 only). Currently identical to emacs editing except that
                 transpose-chars (^T) acts slightly differently.

            <b>-o ignoreeof</b>
                 The shell will not (easily) exit when end-of-file is read;
                 <b>exit</b> must be used. To avoid infinite loops, the shell will
                 exit if EOF is read 13 times in a row.

            <b>-o inherit-xtrace</b>
                 Do not reset <b>-o xtrace</b> upon entering functions. This is en-
                 abled by default.

            <b>-o nohup</b>
                 Do not kill running jobs with a SIGHUP signal when a login
                 shell exits. Currently set by default, but this may change in
                 the future to be compatible with AT&#38;T UNIX <b>ksh</b>, which doesn't
                 have this option, but does send the SIGHUP signal.

            <b>-o nolog</b>
                 No effect. In the original Korn shell, this prevents function
                 definitions from being stored in the history file.

            <b>-o physical</b>
                 Causes the <b>cd</b> and <b>pwd</b> commands to use "physical" (i.e. the
                 filesystem's) ".." directories instead of "logical" direc-
                 tories (i.e. the shell handles "..", which allows the user to
                 be oblivious of symbolic links to directories). Clear by de-
                 fault. Note that setting this option does not affect the
                 current value of the PWD parameter; only the <b>cd</b> command
                 changes PWD. See the <b>cd</b> and <b>pwd</b> commands above for more de-
                 tails.

            <b>-o pipefail</b>
                 Make the exit status of a pipeline (before logically comple-
                 menting) the rightmost non-zero errorlevel, or zero if all
                 commands exited with zero.

            <b>-o posix</b>
                 Behave closer to the standards (see <i>POSIX mode</i> for details).
                 Automatically enabled if the basename of the shell invocation
                 begins with "sh" and this autodetection feature is compiled
                 in (not in MirBSD). As a side effect, setting this flag turns
                 off the <b>braceexpand</b> and <b>utf8-mode</b> flags, which can be turned
                 back on manually, and <b>sh</b> mode (unless both are enabled at the
                 same time).

            <b>-o sh</b>
                 Enable <i>/bin/sh</i> (kludge) mode (see <i>SH mode)</i>. Automatically en-
                 abled if the basename of the shell invocation begins with
                 "sh" and this autodetection feature is compiled in (not in
                 MirBSD). As a side effect, setting this flag turns off
                 <b>braceexpand</b> mode, which can be turned back on manually, and
                 <b>posix</b> mode (unless both are enabled at the same time).

            <b>-o vi</b>
                 Enable vi(1)-like command-line editing (interactive shells
                 only). See <i>Vi editing mode</i> for documentation and limitations.

            <b>-o vi-esccomplete</b>
                 In vi command-line editing, do command and file name comple-
                 tion when escape (^[) is entered in command mode.

            <b>-o vi-tabcomplete</b>
                 In vi command-line editing, do command and file name comple-
                 tion when tab (^I) is entered in insert mode. This is the de-
                 fault.

            <b>-o viraw</b>
                 No effect. In the original Korn shell, unless <b>viraw</b> was set,
                 the vi command-line mode would let the tty(4) driver do the
                 work until ESC (^[) was entered. <b>mksh</b> is always in viraw
                 mode.

            These options can also be used upon invocation of the shell. The
            current set of options (with single letter names) can be found in
            the parameter "$-". <b>set -o</b> with no option name will list all the
            options and whether each is on or off; <b>set +o</b> will print the long
            names of all options that are currently on. In a future version,
            <b>set +o</b> will behave POSIX compliant and print commands to restore
            the current options instead.

            Remaining arguments, if any, are positional parameters and are as-
            signed, in order, to the positional parameters (i.e. $1, $2,
            etc.). If options end with "--" and there are no remaining argu-
            ments, all positional parameters are cleared. If no options or ar-
            guments are given, the values of all names are printed. For unk-
            nown historical reasons, a lone "-" option is treated specially -
            it clears both the <b>-v</b> and <b>-x</b> options.

     <b>shift</b> [<i>number</i>]
            The positional parameters <i>number</i>+1, <i>number</i>+2, etc. are renamed to
            1, 2, etc. <i>number</i> defaults to 1.

     <b>sleep</b> <i>seconds</i>
            Suspends execution for a minimum of the <i>seconds</i> specified as posi-
            tive decimal value with an optional fractional part. Signal
            delivery may continue execution earlier.

     <b>source</b> <i>file</i> [<i>arg</i> ...]
            Like <b>.</b> ("dot"), except that the current working directory is ap-
            pended to the search path (GNU <b>bash</b> extension).

     <b>suspend</b>
            Stops the shell as if it had received the suspend character from
            the terminal. It is not possible to suspend a login shell unless
            the parent process is a member of the same terminal session but is
            a member of a different process group. As a general rule, if the
            shell was started by another shell or via su(1), it can be
            suspended.

     <b>test</b> <i>expression</i>
     <b>[</b> <i>expression</i> <b>]</b>
            <b>test</b> evaluates the <i>expression</i> and returns zero status if true, 1
            if false, or greater than 1 if there was an error. It is normally
            used as the condition command of <b>if</b> and <b>while</b> statements. Symbolic
            links are followed for all <i>file</i> expressions except <b>-h</b> and <b>-L</b>.

            The following basic expressions are available:

            <b>-a</b> <i>file</i>
                 <i>file</i> exists.

            <b>-b</b> <i>file</i>
                 <i>file</i> is a block special device.

            <b>-c</b> <i>file</i>
                 <i>file</i> is a character special device.

            <b>-d</b> <i>file</i>
                 <i>file</i> is a directory.

            <b>-e</b> <i>file</i>
                 <i>file</i> exists.

            <b>-f</b> <i>file</i>
                 <i>file</i> is a regular file.

            <b>-G</b> <i>file</i>
                 <i>file</i>'s group is the shell's effective group ID.

            <b>-g</b> <i>file</i>
                 <i>file</i>'s mode has the setgid bit set.

            <b>-H</b> <i>file</i>
                 <i>file</i> is a context dependent directory (only useful on HP-UX).

            <b>-h</b> <i>file</i>
                 <i>file</i> is a symbolic link.

            <b>-k</b> <i>file</i>
                 <i>file</i>'s mode has the sticky(8) bit set.

            <b>-L</b> <i>file</i>
                 <i>file</i> is a symbolic link.

            <b>-O</b> <i>file</i>
                 <i>file</i>'s owner is the shell's effective user ID.

            <b>-p</b> <i>file</i>
                 <i>file</i> is a named pipe (FIFO).

            <b>-r</b> <i>file</i>
                 <i>file</i> exists and is readable.

            <b>-S</b> <i>file</i>
                 <i>file</i> is a unix(4)-domain socket.

            <b>-s</b> <i>file</i>
                 <i>file</i> is not empty.

            <b>-t</b> <i>fd</i>
                 File descriptor <i>fd</i> is a tty(4) device.

            <b>-u</b> <i>file</i>
                 <i>file</i>'s mode has the setuid bit set.

            <b>-w</b> <i>file</i>
                 <i>file</i> exists and is writable.

            <b>-x</b> <i>file</i>
                 <i>file</i> exists and is executable.

            <i>file1</i> <b>-nt</b> <i>file2</i>
                 <i>file1</i> is newer than <i>file2</i> or <i>file1</i> exists and <i>file2</i> does not.

            <i>file1</i> <b>-ot</b> <i>file2</i>
                 <i>file1</i> is older than <i>file2</i> or <i>file2</i> exists and <i>file1</i> does not.

            <i>file1</i> <b>-ef</b> <i>file2</i>
                 <i>file1</i> is the same file as <i>file2</i>.

            <i>string</i>
                 <i>string</i> has non-zero length.

            <b>-n</b> <i>string</i>
                 <i>string</i> is not empty.

            <b>-z</b> <i>string</i>
                 <i>string</i> is empty.

            <b>-v</b> <i>name</i>
                 The shell parameter <i>name</i> is set.

            <b>-o</b> <i>option</i>
                 Shell <i>option</i> is set (see the <b>set</b> command above for a list of
                 options). As a non-standard extension, if the option starts
                 with a '!', the test is negated; the test always fails if
                 <i>option</i> doesn't exist (so [ -o foo -o -o !foo ] returns true
                 if and only if option <i>foo</i> exists). The same can be achieved
                 with [ -o ?foo ] like in AT&#38;T UNIX <b>ksh93</b>. <i>option</i> can also be
                 the short flag led by either '-' or '+' (no logical
                 negation), for example "-x" or "+x" instead of "xtrace".

            <i>string</i> = <i>string</i>
                 Strings are equal.

            <i>string</i> == <i>string</i>
                 Strings are equal.

            <i>string</i> &#62; <i>string</i>
                 First string operand is greater than second string operand.

            <i>string</i> &#60; <i>string</i>
                 First string operand is less than second string operand.

            <i>string</i> != <i>string</i>
                 Strings are not equal.

            <i>number</i> <b>-eq</b> <i>number</i>
                 Numbers compare equal.

            <i>number</i> <b>-ne</b> <i>number</i>
                 Numbers compare not equal.

            <i>number</i> <b>-ge</b> <i>number</i>
                 Numbers compare greater than or equal.

            <i>number</i> <b>-gt</b> <i>number</i>
                 Numbers compare greater than.

            <i>number</i> <b>-le</b> <i>number</i>
                 Numbers compare less than or equal.

            <i>number</i> <b>-lt</b> <i>number</i>
                 Numbers compare less than.

            The above basic expressions, in which unary operators have pre-
            cedence over binary operators, may be combined with the following
            operators (listed in increasing order of precedence):

                  expr -o expr            Logical OR.
                  expr -a expr            Logical AND.
                  ! expr                  Logical NOT.
                  ( expr )                Grouping.

            Note that a number actually may be an arithmetic expression, such
            as a mathematical term or the name of an integer variable:

                  x=1; [ "x" -eq 1 ]      evaluates to true

            Note that some special rules are applied (courtesy of POSIX) if
            the number of arguments to <b>test</b> or inside the brackets <b>[ ... ]</b> is
            less than five: if leading "!" arguments can be stripped such that
            only one to three arguments remain, then the lowered comparison is
            executed; (thanks to XSI) parentheses <b>\( ... \</b>) lower four- and
            three-argument forms to two- and one-argument forms, respectively;
            three-argument forms ultimately prefer binary operations, followed
            by negation and parenthesis lowering; two- and four-argument forms
            prefer negation followed by parenthesis; the one-argument form al-
            ways implies <b>-n</b>.

            <b>Note</b>: A common mistake is to use "if [ $foo = bar ]" which fails
            if parameter "foo" is empty or unset, if it has embedded spaces
            (i.e. IFS octets) or if it is a unary operator like "!" or "-n".
            Use tests like "if [ x"$foo" = x"bar" ]" instead, or the double-
            bracket operator "if [[ $foo = bar ]]" or, to avoid pattern match-
            ing (see <b>[[</b> above): "if [[ $foo = "$bar" ]]"

            The <b>[[ ... ]]</b> construct is not only more secure to use but also
            often faster.

     <b>time</b> [<b>-p</b>] [<i>pipeline</i>]
            If a <i>pipeline</i> is given, the times used to execute the pipeline are
            reported. If no pipeline is given, then the user and system time
            used by the shell itself, and all the commands it has run since it
            was started, are reported. The times reported are the real time
            (elapsed time from start to finish), the user CPU time (time spent
            running in user mode), and the system CPU time (time spent running
            in kernel mode). Times are reported to standard error; the format
            of the output is:

                  0m0.00s real     0m0.00s user     0m0.00s system

            If the <b>-p</b> option is given the output is slightly longer:

                  real     0.00
                  user     0.00
                  sys      0.00

            It is an error to specify the <b>-p</b> option unless <i>pipeline</i> is a sim-
            ple command.

            Simple redirections of standard error do not affect the output of
            the <b>time</b> command:

                  $ time sleep 1 2&#62;afile
                  $ { time sleep 1; } 2&#62;afile

            Times for the first command do not go to "afile", but those of the
            second command do.

     <b>times</b>  Print the accumulated user and system times used both by the shell
            and by processes that the shell started which have exited. The
            format of the output is:

                  0m0.00s 0m0.00s
                  0m0.00s 0m0.00s

     <b>trap</b> <i>n</i> [<i>signal</i> ...]
            If the first operand is a decimal unsigned integer, this resets
            all specified signals to the default action, i.e. is the same as
            calling <b>trap</b> with a dash ("-") as <i>handler</i>, followed by the argu-
            ments (<i>n</i> [<i>signal</i> ...]), all of which are treated as signals.

     <b>trap</b> [<i>handler signal</i> ...]
            Sets a trap handler that is to be executed when any of the speci-
            fied <i>signal</i>s are received. <i>handler</i> is either an empty string, in-
            dicating the signals are to be ignored, a dash ("-"), indicating
            that the default action is to be taken for the signals (see
            signal(3)), or a string containing shell commands to be executed
            at the first opportunity (i.e. when the current command completes
            or before printing the next PS1 prompt) after receipt of one of
            the signals. <i>signal</i> is the name of a signal (e.g. PIPE or ALRM) or
            the number of the signal (see the <b>kill -l</b> command above).

            There are two special signals: EXIT (also known as 0), which is
            executed when the shell is about to exit, and ERR, which is exe-
            cuted after an error occurs; an error is something that would
            cause the shell to exit if the <b>set -e</b> or <b>set -o errexit</b> option
            were set. EXIT handlers are executed in the environment of the
            last executed command.

            Note that, for non-interactive shells, the trap handler cannot be
            changed for signals that were ignored when the shell started.

            With no arguments, the current state of the traps that have been
            set since the shell started is shown as a series of <b>trap</b> commands.
            Note that the output of <b>trap</b> cannot be usefully piped to another
            process (an artifact of the fact that traps are cleared when sub-
            processes are created).

            The original Korn shell's DEBUG trap and the handling of ERR and
            EXIT traps in functions are not yet implemented.

     <b>true</b>   A command that exits with a zero value.

     <b>typeset</b> [<b>+-aglpnrtUux</b>] [<b>-L</b>[<i>n</i>] | <b>-R</b>[<i>n</i>] | <b>-Z</b>[<i>n</i>]] [<b>-i</b>[<i>n</i>]] [<i>name</i>[=<i>value</i>] ...]
     <b>typeset -f</b> [<b>-tux</b>] [<i>name</i> ...]
            Display or set parameter attributes. This is a declaration utili-
            ty. With no <i>name</i> arguments, parameter attributes are displayed; if
            no options are used, the current attributes of all parameters are
            printed as <b>typeset</b> commands; if an option is given (or "-" with no
            option letter), all parameters and their values with the specified
            attributes are printed; if options are introduced with '+', param-
            eter values are not printed.

            If <i>name</i> arguments are given, the attributes of the named parame-
            ters are set (<b>-</b>) or cleared (<b>+</b>); inside a function, this will
            cause the parameters to be created (with no value) in the local
            scope (but see <b>-g)</b>. Values for parameters may optionally be speci-
            fied. For <i>name</i>[*], the change affects all elements of the array,
            and no value may be specified.

            When <b>-f</b> is used, <b>typeset</b> operates on the attributes of functions.
            As with parameters, if no <i>name</i> arguments are given, functions are
            listed with their values (i.e. definitions) unless options are in-
            troduced with '+', in which case only the function names are re-
            ported.

            <b>-a</b>      Indexed array attribute.

            <b>-f</b>      Function mode. Display or set functions and their attri-
                    butes, instead of parameters.

            <b>-g</b>      Do not cause named parameters to be created in the local
                    scope when called inside a function.

            <b>-i</b>[<i>n</i>]   Integer attribute. <i>n</i> specifies the base to use when
                    displaying the integer (if not specified, the base given
                    in the first assignment is used). Parameters with this at-
                    tribute may be assigned values containing arithmetic ex-
                    pressions.

            <b>-L</b>[<i>n</i>]   Left justify attribute. <i>n</i> specifies the field width. If <i>n</i>
                    is not specified, the current width of a parameter (or the
                    width of its first assigned value) is used. Leading whi-
                    tespace (and zeros, if used with the <b>-Z</b> option) is
                    stripped. If necessary, values are either truncated or
                    space padded to fit the field width.

            <b>-l</b>      Lower case attribute. All upper case ASCII characters in
                    values are converted to lower case. (In the original Korn
                    shell, this parameter meant "long integer" when used with
                    the <b>-i</b> option.)

            <b>-n</b>      Create a bound variable (name reference): any access to
                    the variable <i>name</i> will access the variable <i>value</i> in the
                    current scope (this is different from AT&#38;T UNIX <b>ksh93</b>!)
                    instead. Also different from AT&#38;T UNIX <b>ksh93</b> is that <i>value</i>
                    is lazily evaluated at the time <i>name</i> is accessed. This can
                    be used by functions to access variables whose names are
                    passed as parameters, instead of using <b>eval</b>.

            <b>-p</b>      Print complete <b>typeset</b> commands that can be used to re-
                    create the attributes and values of parameters.

            <b>-R</b>[<i>n</i>]   Right justify attribute. <i>n</i> specifies the field width. If <i>n</i>
                    is not specified, the current width of a parameter (or the
                    width of its first assigned value) is used. Trailing whi-
                    tespace is stripped. If necessary, values are either
                    stripped of leading characters or space padded to make
                    them fit the field width.

            <b>-r</b>      Read-only attribute. Parameters with this attribute may
                    not be assigned to or unset. Once this attribute is set,
                    it cannot be turned off.

            <b>-t</b>      Tag attribute. Has no meaning to the shell; provided for
                    application use.

                    For functions, <b>-t</b> is the trace attribute. When functions
                    with the trace attribute are executed, the <b>xtrace (-x</b>)
                    shell option is temporarily turned on.

            <b>-U</b>      Unsigned integer attribute. Integers are printed as un-
                    signed values (combine with the <b>-i</b> option). This option is
                    not in the original Korn shell.

            <b>-u</b>      Upper case attribute. All lower case ASCII characters in
                    values are converted to upper case. (In the original Korn
                    shell, this parameter meant "unsigned integer" when used
                    with the <b>-i</b> option which meant upper case letters would
                    never be used for bases greater than 10. See the <b>-U</b> op-
                    tion.)

                    For functions, <b>-u</b> is the undefined attribute. See
                    <i>Functions</i> above for the implications of this.

            <b>-x</b>      Export attribute. Parameters (or functions) are placed in
                    the environment of any executed commands. Exported func-
                    tions are not yet implemented.

            <b>-Z</b>[<i>n</i>]   Zero fill attribute. If not combined with <b>-L</b>, this is the
                    same as <b>-R</b>, except zero padding is used instead of space
                    padding. For integers, the number instead of the base is
                    padded.

            If any of the <b>-i</b>, <b>-L</b>, <b>-l</b>, <b>-R</b>, <b>-U</b>, <b>-u</b> or <b>-Z</b> options are changed,
            all others from this set are cleared, unless they are also given
            on the same command line.

     <b>ulimit</b> [<b>-aBCcdefHilMmnOPpqrSsTtVvw</b>] [<i>value</i>]
            Display or set process limits. If no options are used, the file
            size limit (<b>-f</b>) is assumed. <i>value</i>, if specified, may be either an
            arithmetic expression or the word "unlimited". The limits affect
            the shell and any processes created by the shell after a limit is
            imposed. Note that some systems may not allow limits to be in-
            creased once they are set. Also note that the types of limits
            available are system dependent - some systems have only the <b>-f</b>
            limit, or not even that, or can set only the soft limits

            <b>-a</b>     Display all limits; unless <b>-H</b> is used, soft limits are
                   displayed.

            <b>-B</b> <i>n</i>   Set the socket buffer size to <i>n</i> kibibytes.

            <b>-C</b> <i>n</i>   Set the number of cached threads to <i>n</i>.

            <b>-c</b> <i>n</i>   Impose a size limit of <i>n</i> blocks on the size of core dumps.

            <b>-d</b> <i>n</i>   Impose a size limit of <i>n</i> kibibytes on the size of the data
                   area.

            <b>-e</b> <i>n</i>   Set the maximum niceness to <i>n</i>.

            <b>-f</b> <i>n</i>   Impose a size limit of <i>n</i> blocks on files written by the
                   shell and its child processes (files of any size may be
                   read).

            <b>-H</b>     Set the hard limit only (the default is to set both hard
                   and soft limits).

            <b>-i</b> <i>n</i>   Set the number of pending signals to <i>n</i>.

            <b>-l</b> <i>n</i>   Impose a limit of <i>n</i> kibibytes on the amount of locked
                   (wired) physical memory.

            <b>-M</b> <i>n</i>   Set the AIO locked memory to <i>n</i> kibibytes.

            <b>-m</b> <i>n</i>   Impose a limit of <i>n</i> kibibytes on the amount of physical
                   memory used.

            <b>-n</b> <i>n</i>   Impose a limit of <i>n</i> file descriptors that can be open at
                   once.

            <b>-O</b> <i>n</i>   Set the number of AIO operations to <i>n</i>.

            <b>-P</b> <i>n</i>   Limit the number of threads per process to <i>n</i>.

            <b>-p</b> <i>n</i>   Impose a limit of <i>n</i> processes that can be run by the user
                   at any one time.

            <b>-q</b> <i>n</i>   Limit the size of POSIX message queues to <i>n</i> bytes.

            <b>-r</b> <i>n</i>   Set the maximum real-time priority to <i>n</i>.

            <b>-S</b>     Set the soft limit only (the default is to set both hard
                   and soft limits).

            <b>-s</b> <i>n</i>   Impose a size limit of <i>n</i> kibibytes on the size of the stack
                   area.

            <b>-T</b> <i>n</i>   Impose a time limit of <i>n</i> real seconds to be used by each
                   process.

            <b>-t</b> <i>n</i>   Impose a time limit of <i>n</i> CPU seconds spent in user mode to
                   be used by each process.

            <b>-V</b> <i>n</i>   Set the number of vnode monitors on Haiku to <i>n</i>.

            <b>-v</b> <i>n</i>   Impose a limit of <i>n</i> kibibytes on the amount of virtual
                   memory (address space) used.

            <b>-w</b> <i>n</i>   Impose a limit of <i>n</i> kibibytes on the amount of swap space
                   used.

            As far as <b>ulimit</b> is concerned, a block is 512 bytes.

     <b>umask</b> [<b>-S</b>] [<i>mask</i>]
            Display or set the file permission creation mask or umask (see
            umask(2)). If the <b>-S</b> option is used, the mask displayed or set is
            symbolic; otherwise, it is an octal number.

            Symbolic masks are like those used by chmod(1). When used, they
            describe what permissions may be made available (as opposed to oc-
            tal masks in which a set bit means the corresponding bit is to be
            cleared). For example, "ug=rwx,o=" sets the mask so files will not
            be readable, writable or executable by "others", and is equivalent
            (on most systems) to the octal mask "007".

     <b>unalias</b> [<b>-adt</b>] [<i>name</i> ...]
            The aliases for the given names are removed. If the <b>-a</b> option is
            used, all aliases are removed. If the <b>-t</b> or <b>-d</b> options are used,
            the indicated operations are carried out on tracked or directory
            aliases, respectively.

     <b>unset</b> [<b>-fv</b>] <i>parameter</i> ...
            Unset the named parameters (<b>-v</b>, the default) or functions (<b>-f)</b>.
            With <i>parameter</i>[*], attributes are kept, only values are unset.

            The exit status is non-zero if any of the parameters have the
            read-only attribute set, zero otherwise.

     <b>wait</b> [<i>job</i> ...]
            Wait for the specified job(s) to finish. The exit status of <b>wait</b>
            is that of the last specified job; if the last job is killed by a
            signal, the exit status is 128 + the number of the signal (see
            <b>kill -l</b> <i>exit-status</i> above); if the last specified job can't be
            found (because it never existed or had already finished), the exit
            status of <b>wait</b> is 127. See <i>Job control</i> below for the format of
            <i>job</i>. <b>wait</b> will return if a signal for which a trap has been set is
            received or if a SIGHUP, SIGINT or SIGQUIT signal is received.

            If no jobs are specified, <b>wait</b> waits for all currently running
            jobs (if any) to finish and exits with a zero status. If job moni-
            toring is enabled, the completion status of jobs is printed (this
            is not the case when jobs are explicitly specified).

     <b>whence</b> [<b>-pv</b>] [<i>name</i> ...]
            Without the <b>-v</b> option, it is the same as <b>command -v</b>, except
            aliases are not printed as alias command. With the <b>-v</b> option, it
            is exactly the same as <b>command -V</b>. In either case, the <b>-p</b> option
            differs: the search path is not affected in <b>whence</b>, but the search
            is restricted to the path.
</pre><h3>Job control</h3><pre>
     Job control refers to the shell's ability to monitor and control jobs
     which are processes or groups of processes created for commands or pipe-
     lines. At a minimum, the shell keeps track of the status of the back-
     ground (i.e. asynchronous) jobs that currently exist; this information
     can be displayed using the <b>jobs</b> commands. If job control is fully enabled
     (using <b>set -m</b> or <b>set -o monitor)</b>, as it is for interactive shells, the
     processes of a job are placed in their own process group. Foreground jobs
     can be stopped by typing the suspend character from the terminal (normal-
     ly ^Z), jobs can be restarted in either the foreground or background us-
     ing the <b>fg</b> and <b>bg</b> commands, and the state of the terminal is saved or re-
     stored when a foreground job is stopped or restarted, respectively.

     Note that only commands that create processes (e.g. asynchronous com-
     mands, subshell commands and non-built-in, non-function commands) can be
     stopped; commands like <b>read</b> cannot be.

     When a job is created, it is assigned a job number. For interactive
     shells, this number is printed inside "[...]", followed by the process
     IDs of the processes in the job when an asynchronous command is run. A
     job may be referred to in the <b>bg</b>, <b>fg</b>, <b>jobs</b>, <b>kill</b> and <b>wait</b> commands either
     by the process ID of the last process in the command pipeline (as stored
     in the <b>$!</b> parameter) or by prefixing the job number with a percent sign
     ('%'). Other percent sequences can also be used to refer to jobs:

     %+ | %% | %    The most recently stopped job or, if there are no stopped
                    jobs, the oldest running job.

     %-             The job that would be the <b>%+</b> job if the latter did not ex-
                    ist.

     %<i>n</i>             The job with job number <i>n</i>.

     %?<i>string</i>       The job with its command containing the string <i>string</i> (an
                    error occurs if multiple jobs are matched).

     %<i>string</i>        The job with its command starting with the string <i>string</i>
                    (an error occurs if multiple jobs are matched).

     When a job changes state (e.g. a background job finishes or foreground
     job is stopped), the shell prints the following status information:

           [<i>number</i>] <i>flag status command</i>

     where...

     <i>number</i>   is the job number of the job;

     <i>flag</i>     is the '+' or '-' character if the job is the <b>%+</b> or <b>%-</b> job,
              respectively, or space if it is neither;

     <i>status</i>   indicates the current state of the job and can be:

              Done [<i>number</i>]
                         The job exited. <i>number</i> is the exit status of the job
                         which is omitted if the status is zero.

              Running    The job has neither stopped nor exited (note that
                         running does not necessarily mean consuming CPU time
                         - the process could be blocked waiting for some
                         event).

              Stopped [<i>signal</i>]
                         The job was stopped by the indicated <i>signal</i> (if no
                         signal is given, the job was stopped by SIGTSTP).

              <i>signal-description</i> ["core dumped"]
                         The job was killed by a signal (e.g. memory fault,
                         hangup); use <b>kill -l</b> for a list of signal descrip-
                         tions. The "core dumped" message indicates the pro-
                         cess created a core file.

     <i>command</i>  is the command that created the process. If there are multiple
              processes in the job, each process will have a line showing its
              <i>command</i> and possibly its <i>status</i>, if it is different from the
              status of the previous process.

     When an attempt is made to exit the shell while there are jobs in the
     stopped state, the shell warns the user that there are stopped jobs and
     does not exit. If another attempt is immediately made to exit the shell,
     the stopped jobs are sent a SIGHUP signal and the shell exits. Similarly,
     if the <b>nohup</b> option is not set and there are running jobs when an attempt
     is made to exit a login shell, the shell warns the user and does not
     exit. If another attempt is immediately made to exit the shell, the run-
     ning jobs are sent a SIGHUP signal and the shell exits.
</pre><h3>POSIX mode</h3><pre>
     Entering <b>set -o posix</b> mode will cause <b>mksh</b> to behave even more POSIX com-
     pliant in places where the defaults or opinions differ. Note that <b>mksh</b>
     will still operate with unsigned 32-bit arithmetic; use <b>lksh</b> if arithmet-
     ic on the host <i>long</i> data type, complete with ISO C Undefined Behaviour,
     is required; refer to the lksh(1) manual page for details. Most other
     historic, AT&#38;T UNIX <b>ksh-</b>compatible or opinionated differences can be dis-
     abled by using this mode; these are:

     •   The incompatible GNU <b>bash</b> I/O redirection <b>&#38;&#62;</b><i>file</i> is not supported.

     •   File descriptors created by I/O redirections are inherited by child
         processes.

     •   Numbers with a leading digit zero are interpreted as octal.

     •   The <b>echo</b> builtin does not interpret backslashes and only supports the
         exact option <b>-n</b>.

     •   Alias expansion with a trailing space only reruns on command words.

     •   Tilde expansion follows POSIX instead of Korn shell rules.

     •   The exit status of <b>fg</b> is always 0.

     •   <b>kill -l</b> only lists signal names, all in one line.

     •   <b>getopts</b> does not accept options with a leading '+'.

     •   <b>exec</b> skips builtins, functions and other commands and uses a PATH
         search to determine the utility to execute.
</pre><h3>SH mode</h3><pre>
     Compatibility mode; intended for use with legacy scripts that cannot
     easily be fixed; the changes are as follows:

     •   The incompatible GNU <b>bash</b> I/O redirection <b>&#38;&#62;</b><i>file</i> is not supported.

     •   File descriptors created by I/O redirections are inherited by child
         processes.

     •   The <b>echo</b> builtin does not interpret backslashes and only supports the
         exact option <b>-n</b>, unless built with -DMKSH_MIDNIGHTBSD01ASH_COMPAT.

     •   The substitution operations ${<i>x#pat</i>}, ${<i>x##pat</i>}, ${<i>x%pat</i>}, and
         ${<i>x%%pat</i>} wrongly do not require a parenthesis to be escaped and do
         not parse extglobs.

     •   The getopt construct from lksh(1) passes through the errorlevel.

     •   <b>sh -c</b> eats a leading <b>--</b> if built with -DMKSH_MIDNIGHTBSD01ASH_COMPAT.
</pre><h3>Interactive input line editing</h3><pre>
     The shell supports three modes of reading command lines from a tty(4) in
     an interactive session, controlled by the <b>emacs</b>, <b>gmacs</b> and <b>vi</b> options (at
     most one of these can be set at once). The default is <b>emacs</b>. Editing
     modes can be set explicitly using the <b>set</b> built-in. If none of these op-
     tions are enabled, the shell simply reads lines using the normal tty(4)
     driver. If the <b>emacs</b> or <b>gmacs</b> option is set, the shell allows emacs-like
     editing of the command; similarly, if the <b>vi</b> option is set, the shell al-
     lows vi-like editing of the command. These modes are described in detail
     in the following sections.

     In these editing modes, if a line is longer than the screen width (see
     the COLUMNS parameter), a '&#62;', '+' or '&#60;' character is displayed in the
     last column indicating that there are more characters after, before and
     after, or before the current position, respectively. The line is scrolled
     horizontally as necessary.

     Completed lines are pushed into the history, unless they begin with an
     IFS octet or IFS white space or are the same as the previous line.
</pre><h3>Emacs editing mode</h3><pre>
     When the <b>emacs</b> option is set, interactive input line editing is enabled.
     Warning: This mode is slightly different from the emacs mode in the ori-
     ginal Korn shell. In this mode, various editing commands (typically bound
     to one or more control characters) cause immediate actions without wait-
     ing for a newline. Several editing commands are bound to particular con-
     trol characters when the shell is invoked; these bindings can be changed
     using the <b>bind</b> command.

     The following is a list of available editing commands. Each description
     starts with the name of the command, suffixed with a colon; an [<i>n</i>] (if
     the command can be prefixed with a count); and any keys the command is
     bound to by default, written using caret notation e.g. the ASCII ESC
     character is written as ^[. These control sequences are not case sensi-
     tive. A count prefix for a command is entered using the sequence ^[<i>n</i>,
     where <i>n</i> is a sequence of 1 or more digits. Unless otherwise specified, if
     a count is omitted, it defaults to 1.

     Note that editing command names are used only with the <b>bind</b> command.
     Furthermore, many editing commands are useful only on terminals with a
     visible cursor. The user's tty(4) characters (e.g. ERASE) are bound to
     reasonable substitutes and override the default bindings; their customary
     values are shown in parentheses below. The default bindings were chosen
     to resemble corresponding Emacs key bindings:

     abort: INTR (^C), ^G
             Abort the current command, save it to the history, empty the line
             buffer and set the exit state to interrupted.

     auto-insert: [<i>n</i>]
             Simply causes the character to appear as literal input. Most or-
             dinary characters are bound to this.

     backward-char: [<i>n</i>] ^B, ^XD, ANSI-CurLeft, PC-CurLeft
             Moves the cursor backward <i>n</i> characters.

     backward-word: [<i>n</i>] ^[b, ANSI-Ctrl-CurLeft, ANSI-Alt-CurLeft
             Moves the cursor backward to the beginning of the word; words
             consist of alphanumerics, underscore ('_') and dollar sign ('$')
             characters.

     beginning-of-history: ^[&#60;
             Moves to the beginning of the history.

     beginning-of-line: ^A, ANSI-Home, PC-Home
             Moves the cursor to the beginning of the edited input line.

     capitalise-word: [<i>n</i>] ^[C, ^[c
             Uppercase the first ASCII character in the next <i>n</i> words, leaving
             the cursor past the end of the last word.

     clear-screen: ^[^L
             Prints a compile-time configurable sequence to clear the screen
             and home the cursor, redraws the entire prompt and the currently
             edited input line. The default sequence works for almost all
             standard terminals.

     comment: ^[#
             If the current line does not begin with a comment character, one
             is added at the beginning of the line and the line is entered (as
             if return had been pressed); otherwise, the existing comment
             characters are removed and the cursor is placed at the beginning
             of the line.

     complete: ^[^[
             Automatically completes as much as is unique of the command name
             or the file name containing the cursor. If the entire remaining
             command or file name is unique, a space is printed after its com-
             pletion, unless it is a directory name in which case '/' is ap-
             pended. If there is no command or file name with the current par-
             tial word as its prefix, a bell character is output (usually
             causing a beep to be sounded).

     complete-command: ^X^[
             Automatically completes as much as is unique of the command name
             having the partial word up to the cursor as its prefix, as in the
             <b>complete</b> command above.

     complete-file: ^[^X
             Automatically completes as much as is unique of the file name
             having the partial word up to the cursor as its prefix, as in the
             <b>complete</b> command described above.

     complete-list: ^I, ^[=
             Complete as much as is possible of the current word and list the
             possible completions for it. If only one completion is possible,
             match as in the <b>complete</b> command above. Note that ^I is usually
             generated by the TAB (tabulator) key.

     delete-char-backward: [<i>n</i>] ERASE (^H), ^?, ^H
             Deletes <i>n</i> characters before the cursor.

     delete-char-forward: [<i>n</i>] ANSI-Del, PC-Del
             Deletes <i>n</i> characters after the cursor.

     delete-word-backward: [<i>n</i>] Pfx1+ERASE (^[^H), WERASE (^W), ^[^?, ^[^H, ^[h
             Deletes <i>n</i> words before the cursor.

     delete-word-forward: [<i>n</i>] ^[d
             Deletes characters after the cursor up to the end of <i>n</i> words.

     down-history: [<i>n</i>] ^N, ^XB, ANSI-CurDown, PC-CurDown
             Scrolls the history buffer forward <i>n</i> lines (later). Each input
             line originally starts just after the last entry in the history
             buffer, so <b>down-history</b> is not useful until either
             <b>search-history</b>, <b>search-history-up</b> or <b>up-history</b> has been per-
             formed.

     downcase-word: [<i>n</i>] ^[L, ^[l
             Lowercases the next <i>n</i> words.

     edit-line: [<i>n</i>] ^Xe
             Edit line <i>n</i> or the current line, if not specified, interactively.
             The actual command executed is <b>fc -e ${VISUAL:-${EDITOR:-vi}}</b> <i>n</i>.

     end-of-history: ^[&#62;
             Moves to the end of the history.

     end-of-line: ^E, ANSI-End, PC-End
             Moves the cursor to the end of the input line.

     eot: ^_
             Acts as an end-of-file; this is useful because edit-mode input
             disables normal terminal input canonicalisation.

     eot-or-delete: [<i>n</i>] EOF (^D)
             If alone on a line, same as <b>eot</b>, otherwise, <b>delete-char-forward</b>.

     error: (not bound)
             Error (ring the bell).

     evaluate-region: ^[^E
             Evaluates the text between the mark and the cursor position (the
             entire line if no mark is set) as function substitution (if it
             cannot be parsed, the editing state is unchanged and the bell is
             rung to signal an error); $? is updated accordingly.

     exchange-point-and-mark: ^X^X
             Places the cursor where the mark is and sets the mark to where
             the cursor was.

     expand-file: ^[*
             Appends a '*' to the current word and replaces the word with the
             result of performing file globbing on the word. If no files match
             the pattern, the bell is rung.

     forward-char: [<i>n</i>] ^F, ^XC, ANSI-CurRight, PC-CurRight
             Moves the cursor forward <i>n</i> characters.

     forward-word: [<i>n</i>] ^[f, ANSI-Ctrl-CurRight, ANSI-Alt-CurRight
             Moves the cursor forward to the end of the <i>n</i>th word.

     goto-history: [<i>n</i>] ^[g
             Goes to history number <i>n</i>.

     kill-line: KILL (^U)
             Deletes the entire input line.

     kill-region: ^W
             Deletes the input between the cursor and the mark.

     kill-to-eol: [<i>n</i>] ^K
             Deletes the input from the cursor to the end of the line if <i>n</i> is
             not specified; otherwise deletes characters between the cursor
             and column <i>n</i>.

     list: ^[?
             Prints a sorted, columnated list of command names or file names
             (if any) that can complete the partial word containing the cur-
             sor. Directory names have '/' appended to them.

     list-command: ^X?
             Prints a sorted, columnated list of command names (if any) that
             can complete the partial word containing the cursor.

     list-file: ^X^Y
             Prints a sorted, columnated list of file names (if any) that can
             complete the partial word containing the cursor. File type indi-
             cators are appended as described under <b>list</b> above.

     newline: ^J, ^M
             Causes the current input line to be processed by the shell. The
             current cursor position may be anywhere on the line.

     newline-and-next: ^O
             Causes the current input line to be processed by the shell, and
             the next line from history becomes the current line. This is only
             useful after an <b>up-history</b>, <b>search-history</b> or <b>search-history-up</b>.

     no-op: QUIT (^\)
             This does nothing.

     prefix-1: ^[
             Introduces a 2-character command sequence.

     prefix-2: ^X, ^[[, ^[O
             Introduces a multi-character command sequence.

     prev-hist-word: [<i>n</i>] ^[., ^[_
             The last word or, if given, the <i>n</i>th word (zero-based) of the pre-
             vious (on repeated execution, second-last, third-last, etc.) com-
             mand is inserted at the cursor. Use of this editing command
             trashes the mark.

     quote: ^^, ^V
             The following character is taken literally rather than as an
             editing command.

     redraw: ^L
             Reprints the last line of the prompt string and the current input
             line on a new line.

     search-character-backward: [<i>n</i>] ^[^]
             Search backward in the current line for the <i>n</i>th occurrence of the
             next character typed.

     search-character-forward: [<i>n</i>] ^]
             Search forward in the current line for the <i>n</i>th occurrence of the
             next character typed.

     search-history: ^R
             Enter incremental search mode. The internal history list is
             searched backwards for commands matching the input. An initial
             '^' in the search string anchors the search. The escape key will
             leave search mode. Other commands, including sequences of escape
             as <b>prefix-1</b> followed by a <b>prefix-1</b> or <b>prefix-2</b> key will be exe-
             cuted after leaving search mode. The <b>abort</b> (^G) command will re-
             store the input line before search started. Successive
             <b>search-history</b> commands continue searching backward to the next
             previous occurrence of the pattern. The history buffer retains
             only a finite number of lines; the oldest are discarded as neces-
             sary.

     search-history-up: ANSI-PgUp, PC-PgUp
             Search backwards through the history buffer for commands whose
             beginning match the portion of the input line before the cursor.
             When used on an empty line, this has the same effect as
             <b>up-history</b>.

     search-history-down: ANSI-PgDn, PC-PgDn
             Search forwards through the history buffer for commands whose be-
             ginning match the portion of the input line before the cursor.
             When used on an empty line, this has the same effect as
             <b>down-history</b>. This is only useful after an <b>up-history</b>,
             <b>search-history</b> or <b>search-history-up</b>.

     set-mark-command: ^[&#60;space&#62;
             Set the mark at the cursor position.

     transpose-chars: ^T
             If at the end of line or, if the <b>gmacs</b> option is set, this ex-
             changes the two previous characters; otherwise, it exchanges the
             previous and current characters and moves the cursor one charac-
             ter to the right.

     up-history: [<i>n</i>] ^P, ^XA, ANSI-CurUp, PC-CurUp
             Scrolls the history buffer backward <i>n</i> lines (earlier).

     upcase-word: [<i>n</i>] ^[U, ^[u
             Uppercase the next <i>n</i> words.

     version: ^[^V
             Display the version of <b>mksh</b>. The current edit buffer is restored
             as soon as a key is pressed. The restoring keypress is processed,
             unless it is a space.

     yank: ^Y
             Inserts the most recently killed text string at the current cur-
             sor position.

     yank-pop: ^[y
             Immediately after a <b>yank</b>, replaces the inserted text string with
             the next previously killed text string.

     The tab completion escapes characters the same way as the following code:

     print -nr -- "${x@/[\"-\$\&#38;-*:-?[\\\`{-\}${IFS-$' \t\n'}]/\\$KSH_MATCH}"
</pre><h3>Vi editing mode</h3><pre>
     <i>Note</i>: The vi command-line editing mode is orphaned, yet still functional.
     It is 8-bit clean but specifically does not support UTF-8 or MBCS.

     The vi command-line editor in <b>mksh</b> has basically the same commands as the
     vi(1) editor with the following exceptions:

     •   You start out in insert mode.

     •   There are file name and command completion commands: =, \, *, ^X, ^E,
         ^F and, optionally, &#60;tab&#62; and &#60;esc&#62;.

     •   The <b>_</b> command is different (in <b>mksh</b>, it is the last argument command;
         in vi(1) it goes to the start of the current line).

     •   The <b>/</b> and <b>G</b> commands move in the opposite direction to the <b>j</b> command.

     •   Commands which don't make sense in a single line editor are not
         available (e.g. screen movement commands and ex(1)-style colon (<b>:</b>)
         commands).

     Like vi(1), there are two modes: "insert" mode and "command" mode. In in-
     sert mode, most characters are simply put in the buffer at the current
     cursor position as they are typed; however, some characters are treated
     specially. In particular, the following characters are taken from current
     tty(4) settings (see stty(1)) and have their usual meaning (normal values
     are in parentheses): kill (^U), erase (^?), werase (^W), eof (^D), intr
     (^C) and quit (^\). In addition to the above, the following characters
     are also treated specially in insert mode:

     ^E       Command and file name enumeration (see below).

     ^F       Command and file name completion (see below). If used twice in a
              row, the list of possible completions is displayed; if used a
              third time, the completion is undone.

     ^H       Erases previous character.

     ^J | ^M  End of line. The current line is read, parsed and executed by
              the shell.

     ^V       Literal next. The next character typed is not treated specially
              (can be used to insert the characters being described here).

     ^X       Command and file name expansion (see below).

     &#60;esc&#62;    Puts the editor in command mode (see below).

     &#60;tab&#62;    Optional file name and command completion (see <b>^F</b> above), en-
              abled with <b>set -o vi-tabcomplete</b>.

     In command mode, each character is interpreted as a command. Characters
     that don't correspond to commands, are illegal combinations of commands,
     or are commands that can't be carried out, all cause beeps. In the fol-
     lowing command descriptions, an [<i>n</i>] indicates the command may be prefixed
     by a number (e.g. <b>10l</b> moves right 10 characters); if no number prefix is
     used, <i>n</i> is assumed to be 1 unless otherwise specified. The term "current
     position" refers to the position between the cursor and the character
     preceding the cursor. A "word" is a sequence of letters, digits and un-
     derscore characters or a sequence of non-letter, non-digit, non-
     underscore and non-whitespace characters (e.g. "ab2*&#38;^" contains two
     words) and a "big-word" is a sequence of non-whitespace characters.

     Special <b>mksh</b> vi commands:

     The following commands are not in, or are different from, the normal vi
     file editor:

     [<i>n</i>]_
          Insert a space followed by the <i>n</i>th big-word from the last command in
          the history at the current position and enter insert mode; if <i>n</i> is
          not specified, the last word is inserted.

     #    Insert the comment character ('#') at the start of the current line
          and return the line to the shell (equivalent to <b>I#^J)</b>.

     [<i>n</i>]g
          Like <b>G</b>, except if <i>n</i> is not specified, it goes to the most recent
          remembered line.

     [<i>n</i>]v
          Edit line <i>n</i> using the vi(1) editor; if <i>n</i> is not specified, the
          current line is edited. The actual command executed is <b>fc -e</b>
          <b>${VISUAL:-${EDITOR:-vi}}</b> <i>n</i>.

     * and ^X
          Command or file name expansion is applied to the current big-word
          (with an appended '*' if the word contains no file globbing charac-
          ters) - the big-word is replaced with the resulting words. If the
          current big-word is the first on the line or follows one of the
          characters ';', '|', '&#38;', '(' or ')' and does not contain a slash
          ('/'), then command expansion is done; otherwise file name expansion
          is done. Command expansion will match the big-word against all
          aliases, functions and built-in commands as well as any executable
          files found by searching the directories in the PATH parameter. File
          name expansion matches the big-word against the files in the current
          directory. After expansion, the cursor is placed just past the last
          word and the editor is in insert mode.

     [<i>n</i>]\, [<i>n</i>]^F, [<i>n</i>]&#60;tab&#62;, and [<i>n</i>]&#60;esc&#62;
          Command/file name completion. Replace the current big-word with the
          longest unique match obtained after performing command and file name
          expansion. &#60;tab&#62; is only recognised if the <b>vi-tabcomplete</b> option is
          set, while &#60;esc&#62; is only recognised if the <b>vi-esccomplete</b> option is
          set (see <b>set -o)</b>. If <i>n</i> is specified, the <i>n</i>th possible completion is
          selected (as reported by the command/file name enumeration command).

     = and ^E
          Command/file name enumeration. List all the commands or files that
          match the current big-word.

     ^V   Display the version of <b>mksh</b>. The current edit buffer is restored as
          soon as a key is pressed. The restoring keypress is ignored.

     @<i>c</i>   Macro expansion. Execute the commands found in the alias <i>c</i>.

     Intra-line movement commands:

     [<i>n</i>]h and [<i>n</i>]^H
             Move left <i>n</i> characters.

     [<i>n</i>]l and [<i>n</i>]&#60;space&#62;
             Move right <i>n</i> characters.

     0       Move to column 0.

     ^       Move to the first non-whitespace character.

     [<i>n</i>]|    Move to column <i>n</i>.

     $       Move to the last character.

     [<i>n</i>]b    Move back <i>n</i> words.

     [<i>n</i>]B    Move back <i>n</i> big-words.

     [<i>n</i>]e    Move forward to the end of the word, <i>n</i> times.

     [<i>n</i>]E    Move forward to the end of the big-word, <i>n</i> times.

     [<i>n</i>]w    Move forward <i>n</i> words.

     [<i>n</i>]W    Move forward <i>n</i> big-words.

     %       Find match. The editor looks forward for the nearest parenthesis,
             bracket or brace and then moves the cursor to the matching
             parenthesis, bracket or brace.

     [<i>n</i>]f<i>c</i>   Move forward to the <i>n</i>th occurrence of the character <i>c</i>.

     [<i>n</i>]F<i>c</i>   Move backward to the <i>n</i>th occurrence of the character <i>c</i>.

     [<i>n</i>]t<i>c</i>   Move forward to just before the <i>n</i>th occurrence of the character
             <i>c</i>.

     [<i>n</i>]T<i>c</i>   Move backward to just before the <i>n</i>th occurrence of the character
             <i>c</i>.

     [<i>n</i>];    Repeats the last <b>f</b>, <b>F</b>, <b>t</b> or <b>T</b> command.

     [<i>n</i>],    Repeats the last <b>f</b>, <b>F</b>, <b>t</b> or <b>T</b> command, but moves in the opposite
             direction.

     Inter-line movement commands:

     [<i>n</i>]j, [<i>n</i>]+, and [<i>n</i>]^N
             Move to the <i>n</i>th next line in the history.

     [<i>n</i>]k, [<i>n</i>]-, and [<i>n</i>]^P
             Move to the <i>n</i>th previous line in the history.

     [<i>n</i>]G    Move to line <i>n</i> in the history; if <i>n</i> is not specified, the number
             of the first remembered line is used.

     [<i>n</i>]g    Like <b>G</b>, except if <i>n</i> is not specified, it goes to the most recent
             remembered line.

     [<i>n</i>]<i>/string</i>
             Search backward through the history for the <i>n</i>th line containing
             <i>string</i>; if <i>string</i> starts with '^', the remainder of the string
             must appear at the start of the history line for it to match.

     [<i>n</i>]?<i>string</i>
             Same as <b>/</b>, except it searches forward through the history.

     [<i>n</i>]n    Search for the <i>n</i>th occurrence of the last search string; the
             direction of the search is the same as the last search.

     [<i>n</i>]N    Search for the <i>n</i>th occurrence of the last search string; the
             direction of the search is the opposite of the last search.

     <i>ANSI-CurUp</i>, <i>PC-PgUp</i>
             Take the characters from the beginning of the line to the current
             cursor position as search string and do a backwards history
             search for lines beginning with this string; keep the cursor po-
             sition. This works only in insert mode and keeps it enabled.

     Edit commands

     [<i>n</i>]a    Append text <i>n</i> times; goes into insert mode just after the current
             position. The append is only replicated if command mode is re-
             entered i.e. &#60;esc&#62; is used.

     [<i>n</i>]A    Same as <b>a</b>, except it appends at the end of the line.

     [<i>n</i>]i    Insert text <i>n</i> times; goes into insert mode at the current posi-
             tion. The insertion is only replicated if command mode is re-
             entered i.e. &#60;esc&#62; is used.

     [<i>n</i>]I    Same as <b>i</b>, except the insertion is done just before the first
             non-blank character.

     [<i>n</i>]s    Substitute the next <i>n</i> characters (i.e. delete the characters and
             go into insert mode).

     S       Substitute whole line. All characters from the first non-blank
             character to the end of the line are deleted and insert mode is
             entered.

     [<i>n</i>]c<i>move-cmd</i>
             Change from the current position to the position resulting from <i>n</i>
             <i>move-cmd</i>s (i.e. delete the indicated region and go into insert
             mode); if <i>move-cmd</i> is <b>c</b>, the line starting from the first non-
             blank character is changed.

     C       Change from the current position to the end of the line (i.e.
             delete to the end of the line and go into insert mode).

     [<i>n</i>]x    Delete the next <i>n</i> characters.

     [<i>n</i>]X    Delete the previous <i>n</i> characters.

     D       Delete to the end of the line.

     [<i>n</i>]d<i>move-cmd</i>
             Delete from the current position to the position resulting from <i>n</i>
             <i>move-cmd</i>s; <i>move-cmd</i> is a movement command (see above) or <b>d</b>, in
             which case the current line is deleted.

     [<i>n</i>]r<i>c</i>   Replace the next <i>n</i> characters with the character <i>c</i>.

     [<i>n</i>]R    Replace. Enter insert mode but overwrite existing characters in-
             stead of inserting before existing characters. The replacement is
             repeated <i>n</i> times.

     [<i>n</i>]~    Change the case of the next <i>n</i> characters.

     [<i>n</i>]y<i>move-cmd</i>
             Yank from the current position to the position resulting from <i>n</i>
             <i>move-cmd</i>s into the yank buffer; if <i>move-cmd</i> is <b>y</b>, the whole line
             is yanked.

     Y       Yank from the current position to the end of the line.

     [<i>n</i>]p    Paste the contents of the yank buffer just after the current po-
             sition, <i>n</i> times.

     [<i>n</i>]P    Same as <b>p</b>, except the buffer is pasted at the current position.

     Miscellaneous vi commands

     ^J and ^M
             The current line is read, parsed and executed by the shell.

     ^L and ^R
             Redraw the current line.

     [<i>n</i>].    Redo the last edit command <i>n</i> times.

     u       Undo the last edit command.

     U       Undo all changes that have been made to the current line.

     PC Home, End, Del and cursor keys
             They move as expected, both in insert and command mode.

     <i>intr</i> and <i>quit</i>
             The interrupt and quit terminal characters cause the current line
             to be removed to the history and a new prompt to be printed.
</pre><h2>FILES</h2><pre>
     ~/.mkshrc          User mkshrc profile (non-privileged interactive
                        shells); see <i>Startup files</i>. The location can be
                        changed at compile time (for embedded systems); AOSP
                        Android builds use <i>/system/etc/mkshrc</i>.
     ~/.profile         User profile (non-privileged login shells); see
                        <i>Startup files</i> near the top of this manual.
     /etc/profile       System profile (login shells); see <i>Startup files</i>.
     /etc/shells        Shell database.
     /etc/suid_profile  Suid profile (privileged shells); see <i>Startup files</i>.

     Note: On Android, <i>/system/etc/</i> contains the system and suid profile.
</pre><h2>SEE ALSO</h2><pre>
     awk(1), cat(1), ed(1), getopt(1), lksh(1), sed(1), sh(1), stty(1),
     dup(2), execve(2), getgid(2), getuid(2), mknod(2), mkfifo(2), open(2),
     pipe(2), rename(2), wait(2), getopt(3), nl_langinfo(3), setlocale(3),
     signal(3), system(3), tty(4), shells(5), environ(7), script(7), utf-8(7),
     mknod(8)

     <i>http://www.mirbsd.org/ksh-chan.htm</i>

     Morris Bolsky, <i>The KornShell Command and Programming Language</i>, <i>Prentice</i>
     <i>Hall PTR</i>, xvi + 356 pages, 1989, ISBN 978-0-13-516972-8 (0-13-516972-0).

     Morris I. Bolsky and David G. Korn, <i>The New KornShell Command and</i>
     <i>Programming Language (2nd Edition)</i>, <i>Prentice Hall PTR</i>, xvi + 400 pages,
     1995, ISBN 978-0-13-182700-4 (0-13-182700-6).

     Stephen G. Kochan and Patrick H. Wood, <i>UNIX Shell Programming</i>, <i>Sams</i>, 3rd
     Edition, xiii + 437 pages, 2003, ISBN 978-0-672-32490-1 (0-672-32490-3).

     IEEE Inc., <i>IEEE Standard for Information Technology - Portable Operating</i>
     <i>System Interface (POSIX)</i>, <i>IEEE Press</i>, Part 2: Shell and Utilities,
     xvii + 1195 pages, 1993, ISBN 978-1-55937-255-8 (1-55937-255-9).

     Bill Rosenblatt, <i>Learning the Korn Shell</i>, <i>O'Reilly</i>, 360 pages, 1993, ISBN
     978-1-56592-054-5 (1-56592-054-6).

     Bill Rosenblatt and Arnold Robbins, <i>Learning the Korn Shell</i>, <i>Second</i>
     <i>Edition</i>, <i>O'Reilly</i>, 432 pages, 2002, ISBN 978-0-596-00195-7
     (0-596-00195-9).

     Barry Rosenberg, <i>KornShell Programming Tutorial</i>, <i>Addison-Wesley</i>
     <i>Professional</i>, xxi + 324 pages, 1991, ISBN 978-0-201-56324-5
     (0-201-56324-X).
</pre><h2>AUTHORS</h2><pre>
     <b>The MirBSD Korn Shell</b> is developed by mirabilos &#60;<i>m@mirbsd.org</i>&#62; as part of
     The MirOS Project. This shell is based on the public domain 7th edition
     Bourne shell clone by Charles Forsyth, who kindly agreed to, in countries
     where the Public Domain status of the work may not be valid, grant a
     copyright licence to the general public to deal in the work without res-
     triction and permission to sublicence derivatives under the terms of any
     (OSI approved) Open Source licence, and parts of the BRL shell by Doug A.
     Gwyn, Doug Kingston, Ron Natalie, Arnold Robbins, Lou Salkind and others.
     The first release of <b>pdksh</b> was created by Eric Gisin, and it was subse-
     quently maintained by John R. MacMillan, Simon J. Gerraty and Michael
     Rendell. The effort of several projects, such as Debian and OpenBSD, and
     other contributors including our users, to improve the shell is appreci-
     ated. See the documentation, website and source code (CVS) for details.

     <b>mksh-os2</b> is developed by KO Myung-Hun &#60;<i>komh@chollian.net</i>&#62;.

     <b>mksh-w32</b> is developed by Michael Langguth &#60;<i>lan@scalaris.com</i>&#62;.

     <b>mksh/</b>z/OS is contributed by Daniel Richard G. &#60;<i>skunk@iSKUNK.ORG</i>&#62;.

     The BSD daemon is Copyright (C) Marshall Kirk McKusick. The complete
     legalese is at: <i>http://www.mirbsd.org/TaC-mksh.txt</i>
</pre><h2>CAVEATS</h2><pre>
     <b>mksh</b> provides a consistent 32-bit integer arithmetic implementation, both
     signed and unsigned, with sign of the result of a remainder operation and
     wraparound defined, even (defying POSIX) on 36-bit and 64-bit systems.

     <b>mksh</b> provides a consistent, clear interface normally. This may deviate
     from POSIX in historic or opinionated places. <b>set -o posix</b> (see <i>POSIX</i>
     <i>mode</i> for details) will cause the shell to behave more conformant.

     For the purpose of POSIX, <b>mksh</b> supports only the "C" locale. <b>mksh</b>'s
     <b>utf8-mode</b> <i>must</i> be disabled in POSIX mode, and it only supports the Un-
     icode BMP (Basic Multilingual Plane) and maps raw octets into the
     U+EF80..U+EFFF wide character range; compare <i>Arithmetic expressions</i>. The
     following POSIX <b>sh-</b>compatible code toggles the <b>utf8-mode</b> option dependent
     on the current POSIX locale for mksh to allow using the UTF-8 mode,
     within the constraints outlined above, in code portable across various
     shell implementations:

           case ${KSH_VERSION:-} in
           *MIRBSD KSH*|*LEGACY KSH*)
                   case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
                   *[Uu][Tt][Ff]8*|*[Uu][Tt][Ff]-8*) set -U ;;
                   *) set +U ;;
                   esac ;;
           esac
     In near future, (Unicode) locale tracking will be implemented though.

     See also the FAQ below.
</pre><h2>BUGS</h2><pre>
     Suspending (using ^Z) pipelines like the one below will only suspend the
     currently running part of the pipeline; in this example, "fubar" is im-
     mediately printed on suspension (but not later after an <b>fg)</b>.

           $ /bin/sleep 666 &#38;&#38; echo fubar

     The truncation process involved when changing HISTFILE does not free old
     history entries (leaks memory) and leaks old entries into the new history
     if their line numbers are not overwritten by same-number entries from the
     persistent history file; truncating the on-disc file to HISTSIZE lines
     has always been broken and prone to history file corruption when multiple
     shells are accessing the file; the rollover process for the in-memory
     portion of the history is slow, should use memmove(3).

     This document attempts to describe <b>mksh R56</b> and up, compiled without any
     options impacting functionality, such as MKSH_SMALL, when not called as
     <i>/bin/sh</i> which, on some systems only, enables <b>set -o posix</b> or <b>set -o sh</b>
     automatically (whose behaviour differs across targets), for an operating
     environment supporting all of its advanced needs.

     Please report bugs in <b>mksh</b> to the &#60;<i>miros-mksh@mirbsd.org</i>&#62; mailing list or
     in the #!/bin/mksh (or #ksh) IRC channel at <i>irc.freenode.net</i> (Port 6697
     SSL, 6667 unencrypted), or at: <i>https://launchpad.net/mksh</i>
</pre><h2>FREQUENTLY ASKED QUESTIONS</h2><pre>
     This FAQ attempts to document some of the questions users of <b>mksh</b> or
     readers of this manual page may encounter.
</pre><h3>I'm an Android user, so what's mksh?</h3><pre>
     <b>mksh</b> is a UNIX shell / command interpreter, similar to <b>COMMAND.COM</b> or
     <b>CMD.EXE</b>, which has been included with Android Open Source Project for a
     while now. Basically, it's a program that runs in a terminal (console
     window), takes user input and runs commands or scripts, which it can also
     be asked to do by other programs, even in the background. Any privilege
     pop-ups you might be encountering are thus not <b>mksh</b> issues but questions
     by some other program utilising it.
</pre><h3>I'm an OS/2 user, what do I need to know?</h3><pre>
     Unlike the native command prompt, the current working directory is, for
     security reasons common on Unix systems which the shell is designed for,
     not in the search path at all; if you really need this, run the command
     PATH=.$PATHSEP$PATH or add that to a suitable initialisation file.

     There are two different newline modes for mksh-os2: standard (Unix) mode,
     in which only LF (0A hex) is supported as line separator, and "textmode",
     which also accepts ASCII newlines (CR+LF), like most other tools on OS/2,
     but creating an incompatibility with standard <b>mksh</b>. If you compiled mksh
     from source, you will get the standard Unix mode unless <b>-T</b> is added dur-
     ing compilation; you will most likely have gotten this shell through
     komh's port on Hobbes, or from his OS/2 Factory on eComStation Korea,
     which uses "textmode", though. Most OS/2 users will want to use
     "textmode" unless they need absolute compatibility with Unix <b>mksh</b>.
</pre><h3>How do I start mksh on a specific terminal?</h3><pre>
     Normally:
           mksh -T/dev/tty2

     However, if you want for it to return (e.g. for an embedded system rescue
     shell), use this on your real console device instead:
           mksh -T!/dev/ttyACM0

     <b>mksh</b> can also daemonise (send to the background):
           mksh -T- -c 'exec cdio lock'
</pre><h3>POSIX says...</h3><pre>
     Run the shell in POSIX mode (and possibly <b>lksh</b> instead of <b>mksh</b>):
           set -o posix

  <b>My prompt from &#60;some other shell&#62; does not work!</b>
     Contact us on the mailing list or on IRC, we'll convert it for you.
</pre><h3>Something is going wrong with my while...read loop</h3><pre>
     Most likely, you've encountered the problem in which the shell runs all
     parts of a pipeline as subshell. The inner loop will be executed in a
     subshell and variable changes cannot be propagated if run in a pipeline:

           bar | baz | while read foo; do ...; done

     Note that <b>exit</b> in the inner loop will only exit the subshell and not the
     original shell. Likewise, if the code is inside a function, <b>return</b> in the
     inner loop will only exit the subshell and won't terminate the function.

     Use co-processes instead:

           bar | baz |&#38;
           while read -p foo; do ...; done
           exec 3&#62;&#38;p; exec 3&#62;&#38;-

     If <b>read</b> is run in a loop such as <b>while read foo; do ...; done</b> then lead-
     ing whitespace will be removed (IFS) and backslashes processed. You might
     want to use <b>while IFS= read -r foo; do ...; done</b> for pristine I/O. Simi-
     larly, when using the <b>-a</b> option, use of the <b>-r</b> option might be prudent
     ("read -raN-1 arr &#60;file"); the same applies for NUL-terminated lines:

           find . -type f -print0 |&#38; \
               while IFS= read -d '' -pr filename; do
                   print -r -- "found &#60;${filename#./}&#62;"
           done
</pre><h3>What differences in function-local scopes are there?</h3><pre>
     <b>mksh</b> has a different scope model from AT&#38;T UNIX <b>ksh</b>, which leads to sub-
     tle differences in semantics for identical builtins. This can cause is-
     sues with a <b>nameref</b> to suddenly point to a local variable by accident.

     GNU <b>bash</b> allows unsetting local variables; in <b>mksh</b>, doing so in a func-
     tion allows back access to the global variable (actually the one in the
     next scope up) with the same name. The following code, when run before
     the function definitions, changes the behaviour of <b>unset</b> to behave like
     other shells (the alias can be removed after the definitions):

           case ${KSH_VERSION:-} in
           *MIRBSD KSH*|*LEGACY KSH*)
                   function unset_compat {
                           \\builtin typeset unset_compat_x

                           for unset_compat_x in "$@"; do
                                   eval "\\\\builtin unset $unset_compat_x[*]"
                           done
                   }
                   \\builtin alias unset=unset_compat
                   ;;
           esac

     When a local variable is created (e.g. using <b>local</b>, <b>typeset</b>, <b>integer</b>,
     <b>\\builtin typeset</b>) it does not, like in other shells, inherit the value
     from the global (next scope up) variable with the same name; it is rather
     created without any value (unset but defined).
</pre><h3>I get an error in this regex comparison</h3><pre>
     Use extglobs instead of regexes:
           [[ foo =~ (foo|bar).*baz ]]   # becomes
           [[ foo = *@(foo|bar)*baz* ]]  # instead
</pre><h3>Are there any extensions to avoid?</h3><pre>
     GNU <b>bash</b> supports "&#38;&#62;" (and "|&#38;") to redirect both stdout and stderr in
     one go, but this breaks POSIX and Korn Shell syntax; use POSIX redirec-
     tions instead:
           foo |&#38; bar |&#38; baz &#38;&#62;log                 # GNU bash
           foo 2&#62;&#38;1 | bar 2&#62;&#38;1 | baz &#62;log 2&#62;&#38;1     # POSIX
</pre><h3>^L (Ctrl-L) does not clear the screen</h3><pre>
     Use ^[^L (Escape+Ctrl-L) or rebind it:
           bind '^L=clear-screen'
</pre><h3>^U (Ctrl-U) clears the entire line</h3><pre>
     If it should only delete the line up to the cursor, use:
           bind -m ^U='^[0^K'
</pre><h3>Cursor Up behaves differently from zsh</h3><pre>
     Some shells make Cursor Up search in the history only for commands start-
     ing with what was already entered. <b>mksh</b> separates the shortcuts: Cursor
     Up goes up one command and PgUp searches the history as described above.
</pre><h3>My question is not answered here!</h3><pre>
     Check <i>http://www.mirbsd.org/mksh-faq.htm</i> which contains a collection of
     frequently asked questions about <b>mksh</b> in general, for packagers, etc.
     while these above are in user scope.

MirOS                          August 10, 2017                              63</pre>

<hr /><p style="font-size:xx-small;">Generated on 2017-08-10 19:28:31 by <tt>$MirOS: src/scripts/roff2htm,v 1.88 2017/01/29 00:51:06 tg Exp $</tt></p>
<p>These manual pages and other documentation are <a
 href="https://www.mirbsd.org/man7/BSD-Licence.htm">copyrighted</a> by their respective writers;
 their source is available at our <a href="http://cvs.mirbsd.de/">CVSweb</a>,
 AnonCVS, and other mirrors. The rest is Copyright © 2002–2017 <a
 href="https://www.mirbsd.org/">The MirOS Project</a>, Germany.<br /><span
 style="font-size:3pt; font-style:italic;">This product includes material
 provided by <b>mirabilos</b>.</span></p>
<p style="font-size:x-small;">This manual page’s HTML representation
 is supposed to be <a href="http://validator.w3.org/check/referer">valid
 XHTML/1.1</a>; if not, please send a bug report — diffs preferred.</p>
</body></html>
